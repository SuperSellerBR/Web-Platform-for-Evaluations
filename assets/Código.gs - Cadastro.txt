/** ============================
 *  Web App – Cadastro + Login + Verificação + Reset + Avaliações (v3.16-ai)
 *  Abas:
 *   - Usuários (A1:N1): Timestamp | Nome | E-mail | Telefone | Cidade | UF | CPF | Salt | Hash | Verified | VerifyToken | VerifyExpires | ResetToken | ResetExpires
 *   - AvaliacoesAtribuidas (cabeçalho flexível; ver aliases)
 *   - PartnerVoucherRedeems (code | jobId | estabelecimento | redeemed_at | partner_email | rating | ratingObs)
 *   - Empresas (id | nome | gerenteEmail | endereco | telefone | site | instagram | voucherValor | pdfPadraoURL | formularioURL | relatorioEmail)
 *   - SM_Sources (empresaId | tabName | lastProcessedRow | voucherHeader | jobIdHeader | userEmailHeader | empresaIdHeader | respondentIdHeader)
 *   - AI_Configs (empresaId | metodo | pdfFolderId | tabNameOverride | mapaPilaresJSON | npsHeader | nomeAvaliadoHeader)
 *   - AI_Queue (enqueuedAt | empresaId | tabName | jobId | voucher | user_email | respondentId | evalRow)
 *   - AI_Analises (createdAt | empresaId | metodo | jobId | voucher | user_email | data | avaliado | pilaresJSON | media | aspectosGerais | nps | pontosFortes | pontosFracos | planoAcao | pdfUrl | sentTo | sentAt)
 *   - User_Login_Logs (Timestamp | Email | Result | IP | UserAgent | Notes)
 *  =========================== */
/** ===================== PERF UTILS (comuns) ===================== */
var __HDR_CACHE_MEM = {}; // memo no runtime

function __cacheGet__(k){ try{ const c=CacheService.getScriptCache().get(k); return c?JSON.parse(c):null; }catch(_){ return null; } }
function __cachePut__(k,v,ttl){ try{ CacheService.getScriptCache().put(k, JSON.stringify(v), ttl||120); }catch(_){ } }

/** Retorna o array de cabeçalhos (linha 1) com memo + cache */
function sheetHeaders_(sh){
  var key = 'hdr:'+SpreadsheetApp.getActive().getId()+':'+sh.getName();
  if (__HDR_CACHE_MEM[key]) return __HDR_CACHE_MEM[key];
  var c = __cacheGet__(key);
  if (c) { __HDR_CACHE_MEM[key] = c; return c; }
  var hdr = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0] || [];
  __HDR_CACHE_MEM[key] = hdr;
  __cachePut__(key, hdr, 600);
  return hdr;
}

/** Mapa { headerNormalizado: coluna(1-based) } */
function headerIndexMap_(sh){
  var hdr = sheetHeaders_(sh), map = {};
  for (var i=0;i<hdr.length;i++){
    map[_norm_(hdr[i])] = i+1; // 1-based
  }
  return map;
}

/** Leitura rápida de uma linha inteira */
function readRow_(sh, row){
  return sh.getRange(row, 1, 1, sh.getLastColumn()).getValues()[0];
}

/** Cache simples para respostas puramente de leitura */
function withCache_(key, fn, ttl){
  var v = __cacheGet__(key);
  if (v != null) return v;
  v = fn();
  __cachePut__(key, v, ttl||180);
  return v;
}

/** Cacheia IDs de pastas por caminho (Drive) */
function getOrMakeFolderCached_(pathArr){
  var props = PropertiesService.getScriptProperties();
  var key = 'FOLDER:'+pathArr.join('/');
  var id = props.getProperty(key);
  if (id){
    try { return DriveApp.getFolderById(id); } catch(_){ /* id inválido, recria */ }
  }
  var f = DriveApp.getRootFolder();
  for (var i=0;i<pathArr.length;i++){
    var name = String(pathArr[i]);
    var it = f.getFoldersByName(name);
    f = it.hasNext() ? it.next() : f.createFolder(name);
  }
  props.setProperty(key, f.getId());
  return f;
}
const VERSION = 'v3.16-ai';

// Mapa de handlers declarado antecipadamente para manter o roteamento centralizado no doPost.
var __ACTION_HANDLERS__ = null; // lazily populated para evitar custo de carga inicial desnecessário.
const SHEET_NAME = 'Usuários';
const SPREADSHEET_ID = '1LZqFbTIZVZIWxvmtUaciSdNbzCQNkycjvgkbwbeSypE';

// ——— E-mail / Branding ———
const EMAIL_FROM = 'contato@supersellerbr.com';
const EMAIL_NAME = 'Suporte SuperSeller';
// URL preferencial (Firebase público correto). O PDF usa data URL fallback via _getLogoDataUrl_().
const LOGO_URL = 'https://firebasestorage.googleapis.com/v0/b/supersellerco-f5a61.firebasestorage.app/o/Imagens%2FSUPERSELLERCO_LOGO_small.png?alt=media&token=cfb2f1f3-bbbc-4ead-acd7-7b348f0ce188';

/* ===================== ROUTERS ===================== */
function doGet(e) {
  const p = (e && e.parameter) || {};
  if (p && p.admin === '1') {
    return HtmlService.createHtmlOutputFromFile('Admin')
      .setTitle('SuperSeller — Admin')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  const token = p && p.verify;
  if (token) {
    try {
      const { sheet, row } = findByToken(token);
      if (!row) return html('Token inválido ou expirado.');
      const r = readRow_(sheet, row);
      const expires = new Date(r[11]); // VerifyExpires (col 12)
      if (!expires || expires < new Date()) return html('Token expirado. Solicite novo e-mail de verificação.');
      // Verified (J), VerifyToken (K), VerifyExpires (L) — atualiza em lote
      sheet.getRange(row, 10, 1, 3).setValues([[true, '', '']]);
      return html('E-mail verificado com sucesso! Você já pode voltar ao app e fazer login.');
    } catch (err) { return html('Erro ao verificar: ' + err); }
  }
  return json({ ok: true, time: new Date(), version: VERSION, sheet: SHEET_NAME });
}

function doPost(e) {
  try {
    const bodyStr = (e && e.postData && typeof e.postData.contents === 'string') ? e.postData.contents : '{}';
    let data = {};
    try { data = JSON.parse(bodyStr); }
    catch { return json({ result: 'error', message: 'JSON inválido', version: VERSION }); }
    const action = String(data.action || '');
    if (!action) {
      return json({ result: 'error', message: 'Ação obrigatória', code: 'ACTION_REQUIRED', version: VERSION });
    }
    const actionTrimmed = action.trim();

    // meta básica para logs (se o cliente enviar)
    const ctx = {
      ip: String(
        (data.ip || data._ip || (e && e.parameter && (e.parameter.ip || e.parameter.client_ip || e.parameter.clientIp)) || '')
      ).trim(),
      ua: String(
        (data.ua || data._ua || data.userAgent || (e && e.parameter && (e.parameter.ua || e.parameter.useragent || e.parameter.userAgent)) || '')
      ).trim(),
      app: String((data.app || (e && e.parameter && e.parameter.app) || '')).trim()
    };
    if (!__ACTION_HANDLERS__) __ACTION_HANDLERS__ = buildActionHandlers_();
    const handler = __ACTION_HANDLERS__[actionTrimmed];
    if (handler) {
      return handler(data, ctx, e);
    }

    Logger.log('[doPost] Ação inválida recebida: %s', actionTrimmed);
    return json({ result: 'error', message: 'Ação inválida', code: 'ACTION_NOT_FOUND', version: VERSION });
  } catch (err) {
    Logger.log('[doPost] Erro não tratado na ação "%s": %s', (e && e.postData && e.postData.type) || 'unknown', err);
    return json({ result: 'error', message: String(err), version: VERSION });
  }
}

function buildActionHandlers_(){
  // Estrutura enxuta para manter regras em um único lugar e facilitar auditoria/logs.
  return {
    signup: (payload) => doSignup(payload),
    login: (payload, ctx) => doLogin(payload, ctx),
    checkVerified: (payload) => doCheckVerified(payload),
    resendVerification: (payload) => doResendVerification(payload),
    checkDuplicates: (payload) => doCheckDuplicates(payload),
    requestReset: (payload) => doRequestReset(payload),
    resetPassword: (payload) => doResetPassword(payload),

    listEvaluations: (payload) => {
      const em = String(payload.email || '').trim().toLowerCase();
      if (!em) return json({ result: 'error', code: 'EMAIL_REQUIRED', message: 'Email obrigatório', version: VERSION });
      return json({ result: 'ok', items: listEvaluations_(em), version: VERSION });
    },
    getEvaluation: (payload) => {
      const ev = getEvaluation_(payload.jobId);
      return json(ev ? { result: 'ok', item: ev, version: VERSION } : { result: 'not_found', version: VERSION });
    },
    voucherStatus: (payload) => voucherStatus_(String(payload.code || '')),
    uploadAudio: (payload) => doUploadAudio_(payload),
    getTermsAccepted: (payload) => json(getTermsAccepted_(String(payload.jobId||''))),
    setTermsAccepted: (payload) => json(setTermsAccepted_(String(payload.jobId||''), Boolean(payload.accepted))),

    admin_listCompanies: () => json({ result: 'ok', items: admin_listCompanies_(), version: VERSION }),
    admin_upsertCompany: (payload) => json(admin_upsertCompany_(payload)),
    admin_assignEvaluation: (payload) => json(admin_assignEvaluation_(payload)),
    admin_userSummary: (payload) => json({ result: 'ok', item: admin_userSummary_(String(payload.email||'')), version: VERSION }),
    admin_checkConflicts: (payload) => json({ result: 'ok', conflicts: admin_checkConflicts_(payload), version: VERSION }),
    admin_getUser: (payload) => json(admin_getUser(String(payload.email||'')) || { result:'not_found' }),
    admin_upsertUser: (payload) => json(admin_upsertUser(payload)),
    admin_listVouchers: () => json({ result:'ok', items: admin_listVouchers_(), version: VERSION }),
    admin_listRedeems: () => json({ result:'ok', items: admin_listRedeems_(),  version: VERSION }),
    admin_testEmail: (payload) => json(admin_testEmail_(payload)),

    sm_listSources: () => json({ result:'ok', items: sm_listSources_(), version: VERSION }),
    sm_upsertSource: (payload) => json(sm_upsertSource_(payload)),
    sm_scanAll: () => json({ result:'ok', report: sm_scanAll_(), version: VERSION }),
    sm_scanOne: (payload) => json({ result:'ok', report: sm_scanOne_(String(payload.empresaIdOrTab||'')), version: VERSION }),
    sm_ScanAll: () => json({ result:'ok', report: sm_scanAll_(), version: VERSION }),
  };
}

/** ===================== Termo de Compromisso (persistência) ===================== */
// Mantido fora de doPost para evitar redefinições a cada requisição e reduzir custo de GC.
function getTermsAccepted_(jobId){
  try{
    jobId = String(jobId||'').trim();
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    const sh = getAvaliacoesSheet_();
    const colMap = getHeaderMap_(sh); // ainda usamos para jobId
    const last = sh.getLastRow();
    if (last < 2 || !colMap.jobId) return { result:'not_found' };

    const jobs = sh.getRange(2, colMap.jobId, last-1, 1).getValues().flat();
    const idx  = jobs.findIndex(v => String(v).trim() === jobId);
    if (idx === -1) return { result:'not_found' };
    const row  = idx + 2;

    let c = _findHeaderCol_(sh, 'termosAceitos');
    if (!c) return { result:'ok', accepted:false, row };

    const val = String(sh.getRange(row, c).getValue() || '').trim();
    return { result:'ok', accepted: !!val, row };
  }catch(e){ return { result:'error', message:String(e) }; }
}

function setTermsAccepted_(jobId, accepted){
  try{
    jobId = String(jobId||'').trim();
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    const sh = getAvaliacoesSheet_();
    const colMap = getHeaderMap_(sh);
    const last = sh.getLastRow();
    if (last < 2 || !colMap.jobId) return { result:'not_found' };

    const jobs = sh.getRange(2, colMap.jobId, last-1, 1).getValues().flat();
    const idx  = jobs.findIndex(v => String(v).trim() === jobId);
    if (idx === -1) return { result:'not_found' };
    const row  = idx + 2;

    const c = findOrCreateTermsCol_(sh);
    sh.getRange(row, c).setValue(accepted ? 'ok' : '');

    return { result:'ok', accepted: !!accepted, row };
  }catch(e){ return { result:'error', message:String(e) }; }
}
function _headers_(sh){
  return sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0] || [];
}
function _findHeaderCol_(sh, wanted){
  const needle = _norm_(wanted);
  const headers = _headers_(sh);
  for (let i = 0; i < headers.length; i++){
    if (_norm_(headers[i]) === needle) return i + 1; // 1-based
  }
  return 0;
}
function findOrCreateTermsCol_(sh){
  const headers = _headers_(sh);
  let foundIdx = 0;
  for (let i = 0; i < headers.length; i++){
    const h = _norm_((headers[i] || ''));
    if (h === 'termosaceitos' || h === 'aceitetermos' || h === 'termos' || h === 'termos_ok'){
      foundIdx = foundIdx || (i + 1);
    }
  }
  if (foundIdx) return foundIdx;

  const lc = sh.getLastColumn();
  sh.insertColumnAfter(lc);
  sh.getRange(1, lc + 1).setValue('termosAceitos');
  return lc + 1;
}

/** ===================== Upload de Áudio para o Drive ===================== */
function doUploadAudio_(data){
  try{
    const jobId = String(data.jobId||'').trim();
    const empresaId = String(data.empresaId||'').trim();
    const fileNameIn = String(data.fileName||'').trim();
    const b64 = String(data.data||'').trim();
    const contentType = String(data.contentType||'').trim() || 'audio/m4a';
    if (!jobId || !b64) return json({ result: 'error', message: 'jobId e data (base64) obrigatórios', version: VERSION });

    // Pasta-alvo: SuperSeller/Audios/<empresaId>
    const folder = getOrMakeFolderCached_(['SuperSeller','Audios', String(empresaId||'SemEmpresa')]);

    const safeName = fileNameIn || ('Audio_'+ jobId + '.m4a');
    const blob = Utilities.newBlob(Utilities.base64Decode(b64), contentType, safeName);
    const file = folder.createFile(blob).setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    const id = file.getId();
    // URL direta (adequada para <audio src=...>)
    const url = 'https://drive.google.com/uc?export=download&id=' + id;
    // (opcional) URL de preview do Drive, útil para debug
    const previewUrl = 'https://drive.google.com/file/d/' + id + '/preview';

    // vincula ao registro da avaliação (por jobId)
    try {
      const shA = getAvaliacoesSheet_();
      const colA = getHeaderMap_(shA);
      const last = shA.getLastRow();
      if (last >= 2 && colA.jobId && colA.audioUrl) {
        const colVals = shA.getRange(2, colA.jobId, last-1, 1).getValues().flat();
        const idx = colVals.findIndex(v => String(v).trim() === jobId);
        if (idx !== -1) {
          const row = idx + 2;

          // Atualiza URL do áudio e timestamp
          shA.getRange(row, colA.audioUrl).setValue(url);
          if (colA.audioUploadedAt) shA.getRange(row, colA.audioUploadedAt).setValue(new Date());

          // Verifica se já existe um respondentId (formulário concluído)
          let hasResp = false;
          try {
            if (colA.surveyRespondentId) {
              const rv = String(shA.getRange(row, colA.surveyRespondentId).getValue() || '').trim();
              hasResp = !!rv;
            }
          } catch (_) {}

          // Se form já foi enviado, garanta flags de "form preenchido" para diferentes nomes de coluna (se existirem)
          try {
            if (hasResp) {
              // tenta detectar colunas comuns usadas no front
              var hdrs = _headers_(shA);
              var hdrMap = {};
              for (var i = 0; i < hdrs.length; i++) { hdrMap[_norm_(hdrs[i])] = i + 1; }

              var candidates = ['formfilled', 'formulariopreenchido', 'formpreenchido', 'formok', 'form_ok'];
              for (var c = 0; c < candidates.length; c++) {
                var colIdx = hdrMap[candidates[c]];
                if (colIdx) shA.getRange(row, colIdx).setValue('ok');
              }
            }
          } catch (eFlags) {
            Logger.log('[uploadAudio][flags] ' + eFlags);
          }

          // Status "Concluída" quando já houver resposta do SM
          if (hasResp && colA.status) {
            shA.getRange(row, colA.status).setValue('Concluída');
            if (colA.dataConclusao) shA.getRange(row, colA.dataConclusao).setValue(new Date());
          }
        }
      }
    } catch (e2) { Logger.log('[uploadAudio] vínculo falhou: '+e2); }

    try { enqueueScan_(); } catch (e3) { Logger.log('[uploadAudio] enqueueScan_ falhou: ' + e3); }
    return json({ result: 'ok', url: url, version: VERSION });
  } catch(e){
    return json({ result: 'error', message: String(e), version: VERSION });
  }
  function getOrCreateFolder_(parent, name){ const it=parent.getFoldersByName(name); return it.hasNext()? it.next() : parent.createFolder(name); }
}
/** Agenda um scan assíncrono para não bloquear o upload */
function enqueueScan_(){
  try { ScriptApp.newTrigger('sm_scanAll_').timeBased().after(5000).create(); } catch(_){}
}
/* ===================== SIGNUP / LOGIN / VERIFY / RESET ===================== */
function doSignup(data) {
  const sh = getSheet();
  const nome = String(data.nome || '').trim();
  const email = String(data.email || '').trim().toLowerCase();
  const telefone = String(data.telefone || '').trim();
  const cidade = String(data.cidade || '').trim();
  const uf = String(data.uf || '').trim();
  const cpf = String(data.cpf || '').trim();
  const senha = String(data.senha || '');
  if (!nome || !email || !senha) return json({ result: 'error', message: 'Campos obrigatórios ausentes.' });
  if (findRowByEmail(sh, email)) return json({ result: 'duplicate_email' });
  if (cpf && existsInColumn(sh, 7, cpf)) return json({ result: 'duplicate_cpf' });

  const salt = makeSalt();
  const pepper = getPepper();
  const hash = sha256Hex(senha + '|' + salt + '|' + pepper);
  const verifyToken = makeToken(24);
  const verifyExpires = new Date(Date.now() + 48 * 3600 * 1000); // 48h

  sh.appendRow([ new Date(), nome, email, telefone, cidade, uf, cpf, salt, hash, false, verifyToken, verifyExpires, '', '' ]);
  try { sendVerifyEmail(email, verifyToken); } catch (e) { Logger.log(e); }
  return json({ result: 'ok', message: 'Cadastro criado. Verifique seu e-mail.' });
}

function doLogin(data, ctx) {
  const sh = getSheet();
  const email = String(data.email || '').trim().toLowerCase();
  const senha = String(data.senha || '');
  if (!email || !senha) { logLogin_(email, 'error', 'missing_fields', ctx); return json({ result:'error', message:'Email e senha obrigatórios.' }); }

  const row = findRowByEmail(sh, email);
  if (!row) { logLogin_(email, 'not_found', '', ctx); return json({ result:'not_found' }); }

  // Lê a linha toda de uma vez (mais rápido que múltiplos getRange/getValue)
  const r = readRow_(sh, row);
  // ['Timestamp','Nome','E-mail','Telefone','Cidade','UF','CPF','Salt','Hash','Verified','VerifyToken','VerifyExpires','ResetToken','ResetExpires']
  const salt     = String(r[7]  || ''); // col 8
  const hash     = String(r[8]  || ''); // col 9
  const verified = !!r[9];              // col 10
  const pepper   = getPepper();
  const candidate= sha256Hex(senha + '|' + salt + '|' + pepper);

  if (candidate !== hash) { logLogin_(email, 'invalid_password', '', ctx); return json({ result:'invalid_password' }); }
  if (!verified)          { logLogin_(email, 'not_verified', '', ctx);   return json({ result:'not_verified' }); }

  const nome = String(r[1] || '');
  logLogin_(email, 'ok', '', ctx);
  return json({ result:'ok', nome });
}

function doCheckVerified(data){ const sh=getSheet(); const email=String(data.email||'').trim().toLowerCase(); if(!email)return json({result:'error',message:'Email obrigatório.'}); const row=findRowByEmail(sh,email); if(!row)return json({result:'not_found'}); const verified=Boolean(sh.getRange(row,10).getValue()); return json({result:'ok',verified}); }
function doResendVerification(data){ const sh=getSheet(); const email=String(data.email||'').trim().toLowerCase(); if(!email)return json({result:'error',message:'Email obrigatório.'}); const row=findRowByEmail(sh,email); if(!row)return json({result:'not_found'}); const verified=Boolean(sh.getRange(row,10).getValue()); if(verified)return json({result:'already_verified'}); const token=makeToken(24); const expires=new Date(Date.now()+48*3600*1000); sh.getRange(row,11).setValue(token); sh.getRange(row,12).setValue(expires); try{sendVerifyEmail(email,token);}catch(e){Logger.log(e);} return json({result:'sent'}); }
function doCheckDuplicates(data){ const sh=getSheet(); const email=String(data.email||'').trim().toLowerCase(); const cpf=String(data.cpf||'').trim(); const emailExists=!!findRowByEmail(sh,email); const cpfExists=cpf?existsInColumn(sh,7,cpf):false; return json({result:'ok',emailExists,cpfExists}); }
function doRequestReset(data){
  const sh = getSheet();
  const email = String(data.email||'').trim().toLowerCase();
  if(!email) return json({result:'error',message:'Email obrigatório.'});
  const row = findRowByEmail(sh,email);
  if(!row) return json({result:'not_found'});
  // Código numérico de 6 dígitos (substitui token de 48 chars)
  const token = make6DigitCode();
  const expires = new Date(Date.now()+2*3600*1000);
  sh.getRange(row,13).setValue(token);
  sh.getRange(row,14).setValue(expires);
  try{ sendResetEmail(email, token, expires); } catch(e){ Logger.log(e); }
  return json({result:'sent'});
}
function doResetPassword(data){ const token=String(data.token||'').trim(); const novaSenha=String(data.novaSenha||''); if(!token||!novaSenha)return json({result:'error',message:'Token e nova senha obrigatórios.'}); const {sheet,row}=findByResetToken(token); if(!row)return json({result:'invalid_token'}); const expires=new Date(sheet.getRange(row,14).getValue()); if(!expires||expires<new Date())return json({result:'invalid_token'}); const salt=makeSalt(); const pepper=getPepper(); const hash=sha256Hex(novaSenha+'|'+salt+'|'+pepper); sheet.getRange(row,8).setValue(salt); sheet.getRange(row,9).setValue(hash); sheet.getRange(row,13).setValue(''); sheet.getRange(row,14).setValue(''); return json({result:'ok'}); }

/* ===================== LOGIN LOGS ===================== */
function getLoginLogsSheet_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName('User_Login_Logs');
  if (!sh) { sh = ss.insertSheet('User_Login_Logs'); sh.appendRow(['Timestamp','Email','Result','IP','UserAgent','Notes']); }
  else if (sh.getLastRow() === 0) { sh.appendRow(['Timestamp','Email','Result','IP','UserAgent','Notes']); }
  return sh;
}
function logLogin_(email, result, notes, ctx){
  try{
    const sh = getLoginLogsSheet_();
    const ip = ctx && ctx.ip ? String(ctx.ip) : '';
    const ua = ctx && ctx.ua ? String(ctx.ua) : '';
    sh.appendRow([ new Date(), String(email||'').toLowerCase(), String(result||''), ip, ua, String(notes||'') ]);
  } catch(e){ Logger.log('[LOGIN_LOG] Falha ao registrar: '+e); }
}


/* ===================== EMAIL HELPERS ===================== */
function _emailOpts_(){
  try{
    const aliases = GmailApp.getAliases() || [];
    if (aliases.indexOf(EMAIL_FROM) !== -1) {
      return { from: EMAIL_FROM, name: EMAIL_NAME, replyTo: EMAIL_FROM };
    }
    Logger.log('[EMAIL] Alias não encontrado. Aliases disponíveis: %s', JSON.stringify(aliases));
  } catch(e){ Logger.log('[EMAIL] getAliases falhou: '+e); }
  return { name: EMAIL_NAME, replyTo: EMAIL_FROM };
}
function sendVerifyEmail(email, token){
  const url=ScriptApp.getService().getUrl();
  const link=url?(url+'?verify='+encodeURIComponent(token)):'';
  const subject='Confirme seu e-mail – SuperSeller';
  const html=['<div style="font-family:Inter,Segoe UI,Arial,sans-serif;line-height:1.5;color:#0f2e34">',
              `<p><img src="${LOGO_URL}" alt="SuperSeller" width="200" style="display:block;margin:0;max-width:200px;width:54%;height:auto;"/></p>`,
              '<p>Olá!</p>','<p>Clique para confirmar seu e-mail:</p>',
              link?`<p><a href="${link}" target="_blank">Confirmar e-mail</a></p>`:'',
              '<p>Ou use este código no app:</p>',
              `<p style="font-size:20px;font-weight:800;letter-spacing:1px">${token}</p>`,
              '<p>— Equipe SuperSeller</p>','</div>'].join('');
  try{
    GmailApp.sendEmail(email, subject, `Seu token: ${token}`, { htmlBody: html, ..._emailOpts_() });
    Logger.log('[EMAIL] Verificação enviada para %s', email);
  }catch(e){
    Logger.log('[EMAIL][FALHA GmailApp] %s', e);
    try{ MailApp.sendEmail({ to: email, subject, htmlBody: html, name: EMAIL_NAME, replyTo: EMAIL_FROM });
         Logger.log('[EMAIL] Enviado via MailApp (fallback) para %s', email);
    }catch(e2){ Logger.log('[EMAIL][FALHA MailApp] %s', e2); }
  }
}
function sendResetEmail(email, token, expires){
  const subject='Redefinição de senha – SuperSeller';
  const html=['<div style="font-family:Inter,Segoe UI,Arial,sans-serif;line-height:1.5;color:#0f2e34">',
              `<p><img src="${LOGO_URL}" alt="SuperSeller" width="200" style="display:block;margin:0;max-width:200px;width:54%;height:auto;"/></p>`,
              '<p>Você solicitou redefinir sua senha.</p>','<p>Cole este token no app:</p>',
              `<p style="font-size:22px;font-weight:800;letter-spacing:2px">${token}</p>`,
              `<p style="color:#334155">Validade: ${Utilities.formatDate(new Date(expires), Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm')}</p>`,
              '<p>Se não foi você, ignore este e-mail.</p>','</div>'].join('');
  try{
    GmailApp.sendEmail(email, subject, `Token: ${token}`, { htmlBody: html, ..._emailOpts_() });
    Logger.log('[EMAIL] Reset enviado para %s', email);
  }catch(e){
    Logger.log('[EMAIL][FALHA GmailApp] %s', e);
    try{ MailApp.sendEmail({ to: email, subject, htmlBody: html, name: EMAIL_NAME, replyTo: EMAIL_FROM });
         Logger.log('[EMAIL] Enviado via MailApp (fallback) para %s', email);
    }catch(e2){ Logger.log('[EMAIL][FALHA MailApp] %s', e2); }
  }
}

/** ===================== ASSIGNMENT EMAIL ===================== */
function sendAssignmentEmail_(opts){
  try{
    const {
      to,
      avaliadorNome,
      empresaNome,
      empresaId,
      dataISO,
      jobId,
      voucherCodigo,
      formularioURL
    } = opts || {};
    if(!to) return;

    const tz   = Session.getScriptTimeZone();
    let dataBR = '';
    try {
      // dataISO esperado "YYYY-MM-DD"
      const [y,m,d] = String(dataISO||'').split('-').map(Number);
      if (y && m && d) {
        dataBR = Utilities.formatDate(new Date(y, m-1, d), tz, 'dd/MM/yyyy');
      }
    } catch(_){ dataBR = String(dataISO||''); }

    const nome = String(avaliadorNome||'').trim() || String(to).split('@')[0];

    const appUrl = 'https://clienteoculto.supersellerbr.com';
    const waUrl = 'https://wa.me/5562994499597?text=' + encodeURIComponent(`Olá, Gostaria de falar sobre a avaliação do dia ${dataBR||dataISO||''} em ${empresaNome||''}`);
    const formLink = String(formularioURL||'').trim() || 'https://clienteoculto.supersellerbr.com';
    // Helper para adicionar parâmetros à URL
    const CUSTOM_VAR_ALIASES = {
      voucher: ['voucher'],
      job_id: ['job_id','jobId','jobid','job'],
      user_email: ['user_email','userEmail','useremail','email'],
      empresaId: ['empresaId','empresaid','empresa_id','companyId','company_id']
    };

    function removePlaceholders_(base){
      var cleaned = String(base || '');
      Object.keys(CUSTOM_VAR_ALIASES).forEach(function(key){
        var aliases = CUSTOM_VAR_ALIASES[key] || [key];
        aliases.forEach(function(alias){
          var plain = new RegExp('([?&])' + alias + '=[^&#]*', 'gi');
          var encAlias = encodeURIComponent(alias);
          var bracket = new RegExp('([?&])c%5B' + encAlias + '%5D=[^&#]*', 'gi');
          var bracketRaw = new RegExp('([?&])c\\[' + alias + '\\]=[^&#]*', 'gi');
          var customEncoded = new RegExp('([?&])Custom(?:%20|\+)?Variable(?::|%3A|%253A)?(?:%20|\+)?' + encAlias + '=[^&#]*', 'gi');
          var customRaw = new RegExp('([?&])Custom Variable: ' + alias + '=[^&#]*', 'gi');
          cleaned = cleaned
            .replace(plain, '$1')
            .replace(bracket, '$1')
            .replace(bracketRaw, '$1')
            .replace(customEncoded, '$1')
            .replace(customRaw, '$1');
        });
      });
      cleaned = cleaned
        .replace(/\?&/g, '?')
        .replace(/&&/g, '&')
        .replace(/([?&])($|#)/g, '$2');
      return cleaned;
    }

    function appendParams_(url, params){
      try{
        var parts = String(url||'').split('#');
        var base = removePlaceholders_(parts[0] || '');
        var hash = parts.length > 1 ? ('#' + parts.slice(1).join('#')) : '';
        if (!base) return url;
        var qArr = [];
        Object.keys(params||{}).forEach(function(key){
          var valRaw = params[key];
          if (valRaw === null || valRaw === undefined) return;
          var val = String(valRaw);
          if (val === '' || val === 'undefined' || val === 'null') return;
          var encVal = encodeURIComponent(val);
          var aliases = CUSTOM_VAR_ALIASES[key] || [key];
          aliases.forEach(function(alias){
            var encAlias = encodeURIComponent(alias);
            qArr.push(encAlias + '=' + encVal);
            qArr.push(encodeURIComponent('c[' + alias + ']') + '=' + encVal);
          });
        });
        var q = qArr.join('&');
        if (!q) return url;
        var sep = base.indexOf('?') !== -1 ? '&' : '?';
        return base + sep + q + hash;
      }catch(_){ return url; }
    }
    // Custom variables (SurveyMonkey): voucher, job_id, user_email, empresaId
    const formLinkWithParams = appendParams_(formLink, {
      voucher: voucherCodigo || '',
      job_id: jobId || '',
      user_email: to || '',
      empresaId: empresaId || ''
    });

    const subject = `Confirmação da sua avaliação em ${empresaNome||''}`;

    const html = [
      '<div style="font-family:Inter,Segoe UI,Arial,sans-serif;line-height:1.6;color:#0f2e34;padding:8px 2px">',
      `<p style="text-align:left;margin:8px 0 12px">
          <img src="${LOGO_URL}" alt="SuperSeller" width="200"
              style="display:block;margin:0;max-width:200px;width:54%;height:auto;"/>
        </p>`,
      `<p>Olá, <b>${nome}</b></p>`,
      `<p>Sua avaliação de cliente oculto em <b>${empresaNome||''}</b> no dia <b>${dataBR||dataISO||''}</b> está confirmada!</p>`,
      `<p>Acesse sua conta no app: <a href="${appUrl}" target="_blank">${appUrl}</a>.</p>`,
      '<hr style="border:none;border-top:1px solid #e2e8f0;margin:14px 0"/>',
      '<h3 style="margin:10px 0 6px">Etapa 1 – Login</h3>',
      '<ol>',
      '<li>Abra o app e faça login com o e-mail cadastrado e a senha (5 últimos dígitos do seu CPF, se não foi alterada).</li>',
      '<li>Vá até a aba <b>Avaliações</b> e selecione a avaliação atribuída.</li>',
      '<li>Na tela inicial da avaliação você verá:<ul>',
      '<li>Informações do estabelecimento (nome, endereço, etc.).</li>',
      '<li>Um passo a passo resumido explicando as etapas.</li>',
      '<li>O botão para visualizar o <b>Padrão de Atendimento</b>.</li>',
      '<li>Um checkbox de <b>Termo de Compromisso</b>.<br/> * Você precisa marcar “Li e concordo com o Termo de Compromisso” para liberar o botão <b>Próximo Passo</b>.</li>',
      '</ul></li>',
      '</ol>',
      '<h3 style="margin:10px 0 6px">Etapa 2 – Voucher</h3>',
      '<ol>',
      '<li>O sistema mostrará as instruções para apresentação do voucher no local.</li>',
      '<li>O código/QR do voucher será exibido para ser usado no pagamento.</li>',
      '<li>Assim que o voucher for validado, o botão <b>“Passo final”</b> será liberado.</li>',
      '</ol>',
      '<h3 style="margin:10px 0 6px">Etapa 3 – Registro da Experiência</h3>',
      '<ol>',
      '<li>Leia as instruções de preenchimento do formulário.</li>',
      '<li>Clique em <b>Abrir Formulário</b> — você será direcionado ao questionário.</li>',
      '<li>Após preencher o formulário, volte ao app:<ul>',
      '<li>Grave seu áudio de relato (até 2 min) usando o botão <b>Gravar Áudio</b>.</li>',
      '<li>O áudio será enviado automaticamente e ficará registrado na avaliação.</li>',
      '</ul></li>',
      '</ol>',
      '<h3 style="margin:10px 0 6px">Concluindo</h3>',
      '<ul>',
      '<li>A avaliação só é considerada <b>Concluída</b> quando:</li>',
      '<li>O formulário foi preenchido ✅</li>',
      '<li>O áudio foi enviado ✅</li>',
      '<li>Você poderá acompanhar o status em tempo real no app.</li>',
      '</ul>',
      '<hr style="border:none;border-top:1px solid #e2e8f0;margin:14px 0"/>',
      `<p><b>Código da sua avaliação:</b> ${jobId||''}<br/><b>Voucher:</b> ${voucherCodigo||''}</p>`,
      `<p>Caso tenha dúvidas ou precise alterar sua avaliação, entre em contato pelo nosso <a href="${waUrl}" target="_blank"> WhatsApp <i class="fab fa-whatsapp" style="color:#25D366"></i></a></p>`,
      '<p>Tenha uma ótima experiência!</p>',
      // --- BEGIN system requirements and fallback block ---
      '<hr style="border:none;border-top:1px solid #e2e8f0;margin:14px 0"/>',
      '<h3 style="margin:10px 0 6px">ℹ️ Requisitos do sistema</h3>',
      '<p>Nosso app funciona em celulares modernos com câmera e microfone ativos e pelo menos 200&nbsp;MB livres.</p>',
      '<ul style="margin:6px 0 10px 18px;padding:0">',
      '<li>Android 6.0 ou superior (64‑bit recomendado).</li>',
      '<li>iOS 13.4 ou superior (iPhone 8/SE 2ª geração em diante).</li>',
      '<li>Conexão Wi‑Fi ou 4G estável.</li>',
      '</ul>',
      '<h3 style="margin:10px 0 6px">Seu celular não é compatível?</h3>',
      '<p>Sem problemas! Você consegue concluir sua avaliação mesmo assim:</p>',
      '<ol style="margin:6px 0 0 18px;padding:0">',
      `<li><b>Voucher:</b> apresente o código <b>${voucherCodigo||''}</b> ao gerente no momento do pagamento.</li>`,
      `<li><b>Formulário:</b> responda pelo link direto: <a href="${formLinkWithParams}" target="_blank" rel="noopener">Abrir formulário</a>.</li>`,
      `<li><b>Áudio:</b> se não conseguir gravar pelo app, envie um áudio curto pelo <a href="${waUrl}" target="_blank" rel="noopener">nosso WhatsApp</a>.</li>`,
      '</ol>',
      // --- END system requirements and fallback block ---
      '</div>'
    ].join('');

    const plain = [
      `Olá, ${nome}`,
      '',
      `Sua avaliação cliente oculto em ${empresaNome||''} no dia ${dataBR||dataISO||''} está confirmada!`,
      'Acesse sua conta no app: https://clienteoculto.supersellerbr.com',
      '',
      'Etapa 1 – Login',
      '1) Abra o app e faça login com o e-mail cadastrado e a senha (5 últimos dígitos do seu CPF, se não foi alterada).',
      '2) Vá até a aba Avaliações e selecione a avaliação atribuída.',
      '3) Na tela inicial há um passo a passo, o Padrão de Atendimento e o Termo de Compromisso.',
      '',
      'Etapa 2 – Voucher',
      '1) Siga as instruções e apresente o voucher no local.',
      '2) Use o código/QR do voucher para o pagamento.',
      '3) Após validado, o botão "Passo final" será liberado.',
      '',
      'Etapa 3 – Registro da Experiência',
      '1) Abra e preencha o formulário.',
      '2) Grave seu áudio (até 2 min) e envie pelo app.',
      '',
      `WhatsApp (dúvidas/alterações): ${waUrl}`,
      `Código da avaliação: ${jobId||''}`,
      `Voucher: ${voucherCodigo||''}`,
      '',
      'Tenha uma ótima experiência!',
      'Equipe SuperSeller',
      '',
      '---',
      'Requisitos do sistema',
      '- Android 6.0+ (64-bit recomendado)',
      '- iOS 13.4+ (iPhone 8/SE 2ª geração+)',
      '- Câmera e microfone ativos, ~200 MB livres e internet estável',
      '',
      'Seu celular não é compatível?',
      `1) Voucher: apresente o código ${voucherCodigo||''} ao gerente.`,
      `2) Formulário: use o link direto: ${formLinkWithParams}`,
      `3) Áudio: envie um áudio curto pelo WhatsApp: ${waUrl}`
    ].join('\n');

    GmailApp.sendEmail(to, subject, plain, { htmlBody: html, ..._emailOpts_() });
  }catch(e){
    Logger.log('[EMAIL][ASSIGN] Falha ao enviar e-mail de atribuição: ' + e);
    try{
      const opts = opts || {};
      MailApp.sendEmail({
        to: opts.to,
        subject: `Confirmação da sua avaliação em ${opts.empresaNome||''}`,
        htmlBody: html,
        name: EMAIL_NAME,
        replyTo: EMAIL_FROM
      });
    }catch(e2){ Logger.log('[EMAIL][ASSIGN][FALLBACK] ' + e2); }
  }
}

/* ===================== SHEETS/UTILS ===================== */
function getSheet(){ const ss=SpreadsheetApp.openById(SPREADSHEET_ID); let sh=ss.getSheetByName(SHEET_NAME); if(!sh) sh=ss.insertSheet(SHEET_NAME); if(sh.getLastRow()===0){ sh.appendRow(['Timestamp','Nome','E-mail','Telefone','Cidade','UF','CPF','Salt','Hash','Verified','VerifyToken','VerifyExpires','ResetToken','ResetExpires']); } return sh; }
function existsInColumn(sheet,colIndex,value){ const last=sheet.getLastRow(); if(last<2) return false; const values=sheet.getRange(2,colIndex,last-1,1).getValues().flat(); return values.some(v=>String(v).trim().toLowerCase()===String(value).trim().toLowerCase()); }
function findRowByEmail(sheet,email){ const last=sheet.getLastRow(); if(last<2) return null; const values=sheet.getRange(2,3,last-1,1).getValues().flat(); const idx=values.findIndex(v=>String(v).trim().toLowerCase()===String(email).trim().toLowerCase()); return idx===-1?null:(idx+2); }
function findByToken(token){ const sheet=getSheet(); const last=sheet.getLastRow(); if(last<2) return {sheet,row:null}; const values=sheet.getRange(2,11,last-1,1).getValues().flat(); const idx=values.findIndex(v=>String(v).trim()===String(token).trim()); return {sheet,row:idx===-1?null:(idx+2)}; }
function findByResetToken(token){ const sheet=getSheet(); const last=sheet.getLastRow(); if(last<2) return {sheet,row:null}; const values=sheet.getRange(2,13,last-1,1).getValues().flat(); const idx=values.findIndex(v=>String(v).trim()===String(token).trim()); return {sheet,row:idx===-1?null:(idx+2)}; }
function randomHex(numBytes){ var seed=Utilities.getUuid()+'|'+Date.now()+'|'+Math.random(); var digest=Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256,seed,Utilities.Charset.UTF_8); var hex=digest.map(b=>('0'+(b&0xff).toString(16)).slice(-2)).join(''); return hex.slice(0,numBytes*2); }
function makeSalt(){ return randomHex(16); }
function makeToken(n){ return randomHex(n||24); }
// Gera código numérico de 6 dígitos (com zeros à esquerda)
function make6DigitCode(){
  try{
    // Usa entropia do randomHex e reduz para faixa 0..999999
    var hex = randomHex(4); // 8 hex chars ~ 32 bits
    var num = parseInt(hex, 16);
    var code = String(num % 1000000).padStart(6,'0');
    return code;
  }catch(_){
    // Fallback
    return String(Math.floor(Math.random()*1000000)).padStart(6,'0');
  }
}
function sha256Hex(str){ const raw=Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256,str,Utilities.Charset.UTF_8); return raw.map(b=>('0'+(b&0xff).toString(16)).slice(-2)).join(''); }
function getPepper(){ const props=PropertiesService.getScriptProperties(); return props.getProperty('Pepper') || props.getProperty('PEPPER') || ''; }
function json(obj){ return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON); }
function html(msg){ return HtmlService.createHtmlOutput('<div style="font-family:sans-serif;padding:24px">'+msg+'</div>'); }
function _norm_(s){ return String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase().replace(/[^a-z0-9]+/g,''); }

/* ============ Helpers usados pelo Admin.html (polyfills) ============ */
// Retorna objeto simples (google.script.run espera objetos, não TextOutput)
function ok_(obj) { return obj; }

// Reaproveita suas funções já existentes
function sha256_(str) { return sha256Hex(str); }
function getPepper_() { return getPepper(); }

// Aba de usuários (nome com acento ou sem)

/* ===================================================================
 *                            ADMIN (Empresas/Atribuição)
 * =================================================================== */
function getEmpresasSheet_(){
  const ss=SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh=ss.getSheetByName('Empresas');
  if(!sh){ sh=ss.insertSheet('Empresas'); sh.appendRow(['id','nome','gerenteEmail','endereco','telefone','site','instagram','voucherValor','pdfPadraoURL','formularioURL','relatorioEmail']); }
  else if (sh.getLastRow()===0){ sh.appendRow(['id','nome','gerenteEmail','endereco','telefone','site','instagram','voucherValor','pdfPadraoURL','formularioURL','relatorioEmail']); }
  return sh;
}
function getHeaderMapEmp_(sh){
  const headers=sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const aliases={
    id:['id','empresaid','codigo'], nome:['nome','empresa','estabelecimento'], gerenteEmail:['gerenteemail','emailgerente','manageremail'],
    endereco:['endereco','endereço','address','logradouro'], telefone:['telefone','tel','fone','whatsapp'], site:['site','website','urlsite'],
    instagram:['instagram','ig'], voucherValor:['vouchervalor','valorvoucher','valor'], pdfPadraoURL:['pdfpadraourl','pdfpadrao','padraourl','pdf'],
    formularioURL:['formulariourl','formurl','surveyurl','surveymonkey','formulario'], relatorioEmail:['relatorioemail','reportemail','emailrelatorio','emailrelatório'],
    perfilCliente:['perfilcliente','clienteperfil','perfil','perfilobs','perfilobservacoes','perfilobservações'],
    perfilGenero:['perfilgenero','generoalvo','gêneroalvo','genero','gênero'],
    perfilRenda:['perfilrenda','rendalvo','rendaalvo','renda'],
    perfilIdade:['perfilidade','faixaetaria','faixaetária','idade'],
    perfilInteresses:['perfilinteresses','interessesperfil','interessesalvo','interesses','interesse']
  };
  const hmap={}; headers.forEach((h,i)=>hmap[_norm_(h)]=i+1);
  const col={}; Object.keys(aliases).forEach(k=>{ for(const a of aliases[k]){ const hit=hmap[a]; if(hit){ col[k]=hit; break; } } });
  return col;
}
function makeVoucherCode_(){ const chars='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let s='SSV-'; for(let i=0;i<6;i++) s+=chars.charAt(Math.floor(Math.random()*chars.length)); return s; }
function nextJobId_(){ const today=Utilities.formatDate(new Date(),Session.getScriptTimeZone(),'yyyyMMdd'); const sh=getAvaliacoesSheet_(); const col=getHeaderMap_(sh); const last=sh.getLastRow(); let seq=1;
  if(last>=2 && col.jobId){ const vals=sh.getRange(2,col.jobId,last-1,1).getValues().flat(); const sameDay=vals.map(String).filter(v=>v.indexOf('SS-'+today+'-')===0).map(v=>Number(v.split('-').pop()||'0')||0); if(sameDay.length) seq=Math.max.apply(null,sameDay)+1; }
  return `SS-${today}-${String(seq).padStart(3,'0')}`;
}
function admin_listCompanies_(){
  function _canonGenero_(v){
    var s = _norm_(v);
    if(!s) return '';
    if (s.indexOf('fem')===0 || s==='mulher' || s==='feminino') return 'Feminino';
    if (s.indexOf('masc')===0 || s==='homem' || s==='masculino') return 'Masculino';
    return '';
  }
  function _canonRenda_(v){
    var s = _norm_(v);
    if(!s) return '';
    if (s==='baixa') return 'Baixa';
    if (s==='media' || s==='média') return 'Média';
    if (s==='alta') return 'Alta';
    return '';
  }
  const sh=getEmpresasSheet_(); const last=sh.getLastRow(); if(last<2) return [];
  const col=getHeaderMapEmp_(sh); const vals=sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  return vals.map(r=>({
    id:String(col.id?r[col.id-1]:''), nome:String(col.nome?r[col.nome-1]:''), gerenteEmail:String(col.gerenteEmail?r[col.gerenteEmail-1]:'').toLowerCase(),
    endereco:String(col.endereco?r[col.endereco-1]:''), telefone:String(col.telefone?r[col.telefone-1]:''), site:String(col.site?r[col.site-1]:''), instagram:String(col.instagram?r[col.instagram-1]:''), voucherValor: col.voucherValor?Number(r[col.voucherValor-1]||0):null, pdfPadraoURL:String(col.pdfPadraoURL?r[col.pdfPadraoURL-1]:''), formularioURL:String(col.formularioURL?r[col.formularioURL-1]:''), relatorioEmail:String(col.relatorioEmail?r[col.relatorioEmail-1]:''),
    perfilCliente: String(col.perfilCliente?r[col.perfilCliente-1]:''), perfilGenero: _canonGenero_(col.perfilGenero?r[col.perfilGenero-1]:''), perfilRenda: _canonRenda_(col.perfilRenda?r[col.perfilRenda-1]:''), perfilIdade: String(col.perfilIdade?r[col.perfilIdade-1]:''), perfilInteresses: String(col.perfilInteresses?r[col.perfilInteresses-1]:'')
  })).filter(x=>x.id||x.nome);
}
function admin_upsertCompany_(data){
  const payload=data.company||data; let {id,nome,gerenteEmail,endereco,telefone,site,instagram,voucherValor,pdfPadraoURL,formularioURL,relatorioEmail,
    perfilCliente,perfilGenero,perfilRenda,perfilIdade,perfilInteresses} = payload||{};
  nome=String(nome||'').trim(); gerenteEmail=String(gerenteEmail||'').trim().toLowerCase(); endereco=String(endereco||'').trim(); telefone=String(telefone||'').trim();
  site=String(site||'').trim(); instagram=String(instagram||'').trim(); relatorioEmail=String(relatorioEmail||'').trim().toLowerCase(); voucherValor=(voucherValor===''||voucherValor==null)?'':Number(voucherValor);
  perfilCliente=String(perfilCliente||'').trim(); perfilGenero=String(perfilGenero||'').trim(); perfilRenda=String(perfilRenda||'').trim(); perfilIdade=String(perfilIdade||'').trim(); perfilInteresses=String(perfilInteresses||'').trim();
  if(!nome) return {result:'error',message:'Nome obrigatório',version:VERSION};
  const sh=getEmpresasSheet_(); const col=getHeaderMapEmp_(sh);
  if(!id) id='EMP-'+randomHex(3).toUpperCase();
  let row=null; if(col.id){ const last=sh.getLastRow(); if(last>=2){ const arr=sh.getRange(2,col.id,last-1,1).getValues().flat(); const idx=arr.findIndex(v=>String(v)===String(id)); if(idx!==-1) row=idx+2; } }
  function ensureCol(name,label){
    if(!col[name]){
      var lc = sh.getLastColumn();
      sh.insertColumnAfter(lc);
      sh.getRange(1, lc + 1).setValue(label);
      col[name] = lc + 1;
    }
  }
  ['id','nome','gerenteEmail','endereco','telefone','site','instagram','voucherValor','pdfPadraoURL','formularioURL','relatorioEmail','perfilCliente','perfilGenero','perfilRenda','perfilIdade','perfilInteresses']
    .forEach((k,i)=>ensureCol(k,['id','nome','gerenteEmail','endereco','telefone','site','instagram','voucherValor','pdfPadraoURL','formularioURL','relatorioEmail','perfilCliente','perfilGenero','perfilRenda','perfilIdade','perfilInteresses'][i]));
  const outRow=row || (sh.getLastRow()+1); if(!row) sh.insertRowsAfter(sh.getLastRow(),1);
  const set=(c,v)=>{ if(col[c]) sh.getRange(outRow,col[c]).setValue(v); };
  set('id',id); set('nome',nome); set('gerenteEmail',gerenteEmail); set('endereco',endereco); set('telefone',telefone); set('site',site); set('instagram',instagram);
  if(voucherValor!=='') set('voucherValor', Number(voucherValor)||0);
  if(pdfPadraoURL!=null) set('pdfPadraoURL', String(pdfPadraoURL||''));
  if(formularioURL!=null) set('formularioURL', String(formularioURL||''));
  if(relatorioEmail!=null) set('relatorioEmail', String(relatorioEmail||'').toLowerCase());
  if(perfilCliente!=null) set('perfilCliente', perfilCliente);
  if(perfilGenero!=null) set('perfilGenero', perfilGenero);
  if(perfilRenda!=null) set('perfilRenda', perfilRenda);
  if(perfilIdade!=null) set('perfilIdade', perfilIdade);
  if(perfilInteresses!=null) set('perfilInteresses', perfilInteresses);
  return { result:'ok', item: admin_getCompanyById_(id), version: VERSION };
}
function admin_getCompanyById_(id){
  const sh=getEmpresasSheet_(); const col=getHeaderMapEmp_(sh); if(!col.id) return null; const last=sh.getLastRow(); if(last<2) return null;
  const arr=sh.getRange(2,col.id,last-1,1).getValues().flat(); const idx=arr.findIndex(v=>String(v)===String(id)); if(idx===-1) return null; const row=sh.getRange(idx+2,1,1,sh.getLastColumn()).getValues()[0];
  return {
    id:String(col.id?row[col.id-1]:''), nome:String(col.nome?row[col.nome-1]:''), gerenteEmail:String(col.gerenteEmail?row[col.gerenteEmail-1]:'').toLowerCase(),
    endereco:String(col.endereco?row[col.endereco-1]:''), telefone:String(col.telefone?row[col.telefone-1]:''), site:String(col.site?row[col.site-1]:''), instagram:String(col.instagram?row[col.instagram-1]:''), voucherValor: col.voucherValor?Number(row[col.voucherValor-1]||0):null, pdfPadraoURL:String(row[col.pdfPadraoURL-1]||''), formularioURL:String(row[col.formularioURL-1]||''), relatorioEmail:String(row[col.relatorioEmail-1]||''),
    perfilCliente: String(col.perfilCliente?row[col.perfilCliente-1]:'') , perfilGenero: String(col.perfilGenero?row[col.perfilGenero-1]:''), perfilRenda: String(col.perfilRenda?row[col.perfilRenda-1]:''), perfilIdade: String(col.perfilIdade?row[col.perfilIdade-1]:''), perfilInteresses: String(col.perfilInteresses?row[col.perfilInteresses-1]:'')
  };
}
function admin_userSummary_(emailRaw){
  const email=String(emailRaw||'').trim().toLowerCase(); if(!email) return null;
  const shU=getSheet(); const rowU=findRowByEmail(shU,email); let nome='', telefone=''; if(rowU){ nome=String(shU.getRange(rowU,2).getValue()||''); telefone=String(shU.getRange(rowU,4).getValue()||''); }
  const shA=getAvaliacoesSheet_(); const colA=getHeaderMap_(shA); const lastA=shA.getLastRow(); let codes=[];
  if(lastA>=2 && colA.avaliadorEmail && colA.voucherCodigo){ const vals=shA.getRange(2,1,lastA-1,shA.getLastColumn()).getValues(); for(let i=0;i<vals.length;i++){ const r=mapRowToEvaluation_(vals[i],colA); if(r.avaliadorEmail===email && r.voucherCodigo) codes.push(String(r.voucherCodigo).toLowerCase()); } }
  const shR=getRedeemsSheet_(); const colR=getHeaderMapRedeems_(shR); let ratings=[];
  if(codes.length && colR.code && colR.rating){ const lastR=shR.getLastRow(); if(lastR>=2){ const rows=shR.getRange(2,1,lastR-1,shR.getLastColumn()).getValues(); for(let i=0;i<rows.length;i++){ const c=String(rows[i][colR.code-1]||'').trim().toLowerCase(); if(codes.indexOf(c)!==-1){ const rt=Number(rows[i][colR.rating-1]||0); if(!isNaN(rt)&&rt>0) ratings.push(rt); } } } }
  const avg=ratings.length?(ratings.reduce((a,b)=>a+b,0)/ratings.length):null; return { email, nome, telefone, ratingAvg:avg, ratingCount:ratings.length };
}
function admin_checkConflicts_(data){
  const email=String(data.email||'').trim().toLowerCase(); const empresaId=String(data.empresaId||'').trim(); const dataISO=String(data.dataISO||'').trim();
  const sh=getAvaliacoesSheet_(); const col=getHeaderMap_(sh); const last=sh.getLastRow(); const out={sameCompanyFuture:false,sameDateAnyCompany:false,matches:[]}; if(last<2 || !email) return out;
  const vals=sh.getRange(2,1,last-1,sh.getLastColumn()).getValues(); const today=Utilities.formatDate(new Date(),Session.getScriptTimeZone(),'yyyy-MM-dd');
  for(let i=0;i<vals.length;i++){ const r=mapRowToEvaluation_(vals[i],col); if(r.avaliadorEmail!==email) continue; const st=String(r.status||'').toLowerCase(); const isPending = st!=='concluída' && st!=='expirada';
    if(isPending && r.empresaId && empresaId && r.empresaId===empresaId){ if(r.dataISO && r.dataISO>=today){ out.sameCompanyFuture=true; out.matches.push({jobId:r.jobId,dataISO:r.dataISO,empresaId:r.empresaId,status:r.status}); } }
    if(isPending && dataISO && r.dataISO===dataISO){ out.sameDateAnyCompany=true; out.matches.push({jobId:r.jobId,dataISO:r.dataISO,empresaId:r.empresaId,status:r.status}); } }
  return out;
}
function admin_assignEvaluation_(data){
  const empresaId = String(data.empresaId||'').trim();
  const avaliadorEmail = String(data.email||data.avaliadorEmail||'').trim().toLowerCase();
  const dataISO = String(data.dataISO||'').trim();
  const hora = String(data.hora||'').trim();
  const periodo = String(data.periodo||'').trim();
  const observacoes = String(data.observacoes||'').trim();
  if(!empresaId)      return {result:'error',message:'empresaId obrigatório',version:VERSION};
  if(!avaliadorEmail) return {result:'error',message:'E-mail do avaliador obrigatório',version:VERSION};
  if(!dataISO)        return {result:'error',message:'Data (YYYY-MM-DD) obrigatória',version:VERSION};

  // Empresa
  const emp = admin_getCompanyById_(empresaId);
  if(!emp) return {result:'error',message:'Empresa não encontrada',version:VERSION};

  // Conflitos
  const c = admin_checkConflicts_({ email: avaliadorEmail, empresaId, dataISO });
  if (c.sameCompanyFuture)   return {result:'conflict',type:'same_company_future',conflicts:c,version:VERSION};
  if (c.sameDateAnyCompany)  return {result:'conflict',type:'same_date',conflicts:c,version:VERSION};

  // job + voucher
  const jobId = nextJobId_();
  let voucherCodigo = makeVoucherCode_();

  const shA  = getAvaliacoesSheet_();
  const colA = getHeaderMap_(shA);

  // Evita voucher duplicado
  if (colA.voucherCodigo){
    const lastA = shA.getLastRow();
    if (lastA >= 2){
      const list = shA.getRange(2, colA.voucherCodigo, lastA-1, 1).getValues()
        .flat().map(v => String(v).toLowerCase());
      while (list.indexOf(voucherCodigo.toLowerCase()) !== -1)
        voucherCodigo = makeVoucherCode_();
    }
  }
  // ===== NOVO: obter nome do avaliador na aba Usuários =====
  let avaliadorNome = '';
  try {
    const shU = getSheet(); // aba "Usuários"
    const rowU = findRowByEmail(shU, avaliadorEmail);
    if (rowU) avaliadorNome = String(shU.getRange(rowU, 2).getValue()||''); // col 2 = Nome
  } catch (e) {
    Logger.log('[assign] Falha ao obter nome do avaliador: ' + e);
  }

  // ===== NOVO: garantir colunas extras (avaliadorNome, nomeAvaliador, empresaNome) =====
  function ensureCol(name){
    if (!colA[name]) {
      var lc = shA.getLastColumn();
      shA.insertColumnAfter(lc);
      shA.getRange(1, lc + 1).setValue(name);
      colA[name] = lc + 1;
    }
  }
  ensureCol('avaliadorNome');
  ensureCol('nomeAvaliador');
  ensureCol('empresaNome');

  // Monta a linha conforme cabeçalho atual
  const headers = shA.getRange(1,1,1,shA.getLastColumn()).getValues()[0];
  const row = new Array(headers.length).fill('');
  const set = (key,val)=>{ if(colA[key]) row[colA[key]-1] = val; };

  set('empresaId', empresaId);
  set('jobId', jobId);
  set('avaliadorEmail', avaliadorEmail);
  set('avaliadorNome', avaliadorNome);  // << novo
  set('nomeAvaliador', avaliadorNome);  // << novo (sinônimo)
  set('empresaNome', emp.nome||'');     // << novo

  // Campos informativos da empresa (mantidos)
  set('estabelecimento', emp.nome||'');
  set('endereco',       emp.endereco||'');
  set('telefoneEstab',  emp.telefone||'');
  set('instagram',      emp.instagram||'');
  set('site',           emp.site||'');

  // Data / período
  set('cidade','');
  set('uf','');
  set('dataISO', dataISO);
  set('hora',    hora);
  set('periodo', hora ? '' : periodo);

  // Voucher / status / meta
  set('voucherValor', (data.voucherValor!=null && data.voucherValor!=='') ? Number(data.voucherValor) : (emp.voucherValor || 0));
  set('voucherCodigo', voucherCodigo);
  set('status','Pendente');
  set('observacoes', observacoes);
  set('pdfPadraoURL',  emp.pdfPadraoURL||'');
  set('formularioURL', emp.formularioURL||'');

  shA.appendRow(row);

  // Envia e-mail de confirmação para o avaliador
  try {
    sendAssignmentEmail_({
      to: avaliadorEmail,
      avaliadorNome: avaliadorNome,
      empresaNome: emp.nome || '',
      empresaId: empresaId,
      dataISO: dataISO,
      jobId: jobId,
      voucherCodigo: voucherCodigo,
      formularioURL: emp.formularioURL || ''
    });
  } catch(e) {
    Logger.log('[assign] Falha ao enviar e-mail ao avaliador: ' + e);
  }

  return {
    result: 'ok',
    item: {
      jobId, voucherCodigo, empresaId,
      estabelecimento: emp.nome,
      empresaNome: emp.nome,            // << conveniência
      avaliadorEmail,
      avaliadorNome,                    // << conveniência
      dataISO, hora, periodo
    },
    version: VERSION
  };
}
/** Atualiza campos editáveis de uma avaliação por jobId (dataISO, observacoes) */
function admin_updateEvaluation_(payload){
  try{
    const jobId = String((payload && payload.jobId) || '').trim();
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    const shA = getAvaliacoesSheet_();
    const col = getHeaderMap_(shA);
    const last = shA.getLastRow();
    if(last < 2 || !col.jobId) return { result:'not_found' };

    // acha a linha pelo jobId
    const jobs = shA.getRange(2, col.jobId, last-1, 1).getValues().flat();
    const idx  = jobs.findIndex(v => String(v).trim() === jobId);
    if(idx === -1) return { result:'not_found' };
    const row  = idx + 2;

    // aplica somente campos permitidos
    if(payload.dataISO != null && col.dataISO){
      // espera "YYYY-MM-DD" (input type=date do Admin.html)
      shA.getRange(row, col.dataISO).setValue(String(payload.dataISO||''));
    }
    if(payload.periodo != null && col.periodo){
      shA.getRange(row, col.periodo).setValue(String(payload.periodo||''));
    }
    if(Object.prototype.hasOwnProperty.call(payload, 'voucherValor') && col.voucherValor){
      var vv = payload.voucherValor;
      if (vv === '' || vv === null || typeof vv === 'undefined') shA.getRange(row, col.voucherValor).setValue('');
      else shA.getRange(row, col.voucherValor).setValue(Number(vv));
    }
    if(payload.observacoes != null && col.observacoes){
      shA.getRange(row, col.observacoes).setValue(String(payload.observacoes||''));
    }

    return { result:'ok' };
  } catch(e){
    return { result:'error', message: String(e) };
  }
}

/** Cancela a avaliação (status = "Cancelada") por jobId */
function admin_cancelEvaluation_(payload){
  try{
    const jobId = String((payload && payload.jobId) || '').trim();
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    const shA = getAvaliacoesSheet_();
    const col = getHeaderMap_(shA);
    const last = shA.getLastRow();
    if(last < 2 || !col.jobId || !col.status) return { result:'not_found' };

    const jobs = shA.getRange(2, col.jobId, last-1, 1).getValues().flat();
    const idx  = jobs.findIndex(v => String(v).trim() === jobId);
    if(idx === -1) return { result:'not_found' };
    const row  = idx + 2;

    shA.getRange(row, col.status).setValue('Cancelada');
    return { result:'ok' };
  } catch(e){
    return { result:'error', message: String(e) };
  }
}

// Exports chamados pelo Admin.html
function admin_updateEvaluation(p){ return admin_updateEvaluation_(p); }
function admin_cancelEvaluation(p){ return admin_cancelEvaluation_(p); }

/** Exclui definitivamente a avaliação por jobId na aba AvaliacoesAtribuidas */
function admin_deleteEvaluation_(payload){
  try{
    function canonId(v){
      var s = String(v||'').trim();
      if (/^\d+(?:\.0+)?$/.test(s)) { var n = Number(s); if (!isNaN(n)) s = String(Math.floor(n)); }
      return s;
    }
    var jobId = canonId(payload && payload.jobId);
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    var sh = getAvaliacoesSheet_();
    var last = sh.getLastRow();
    if (last < 2) return { result:'not_found' };

    var col = getHeaderMap_(sh);
    var rowToDelete = null;
    if (col.jobId){
      var vals = sh.getRange(2, col.jobId, last-1, 1).getValues().flat();
      var idx  = vals.findIndex(function(v){ return canonId(v) === jobId; });
      if (idx !== -1) rowToDelete = idx + 2;
    }
    if (!rowToDelete){
      // fallback: procura em todas as colunas
      var all = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
      outer: for (var i=0;i<all.length;i++){
        for (var j=0;j<all[i].length;j++){
          if (canonId(all[i][j]) === jobId){ rowToDelete = i+2; break outer; }
        }
      }
    }
    if (!rowToDelete) return { result:'not_found' };
    sh.deleteRow(rowToDelete);
    return { result:'ok', deletedRow: rowToDelete };
  } catch(e){
    return { result:'error', message: String(e) };
  }
}

// Exports e aliases compatíveis
function admin_deleteEvaluation(p){ return admin_deleteEvaluation_(p); }
function admin_deleteAssignment(p){ return admin_deleteEvaluation_(p); }
function admin_removeEvaluation(p){ return admin_deleteEvaluation_(p); }
function admin_deleteJob(p){ return admin_deleteEvaluation_(p); }
function admin_deleteByJobId(p){ return admin_deleteEvaluation_(p); }

/** Verifica o status de uma avaliação (se formulário foi preenchido e se tem áudio) */
function admin_getEvaluationStatus_(payload){
  try {
    function canonId(v){
      var s = String(v||'').trim();
      if (/^\d+(?:\.0+)?$/.test(s)) { var n = Number(s); if (!isNaN(n)) s = String(Math.floor(n)); }
      return s;
    }
    var jobId = canonId(payload && payload.jobId);
    if(!jobId) return { result:'error', message:'jobId obrigatório' };

    var status = {
      result: 'success',
      jobId: jobId,
      formSubmitted: false,
      audioSubmitted: false,
      audioUrl: null,
      debug: {
        empresaId: null,
        targetSheetName: null,
        sheetFound: false
      }
    };

    // 1. Verifica se o formulário foi preenchido (busca em abas das empresas)
    // Primeiro, pega a empresa da avaliação
    var shAval = getAvaliacoesSheet_();
    var colAval = getHeaderMap_(shAval);
    var lastAval = shAval.getLastRow();
    var empresaId = null;
    var audioUrl = null;

    if (lastAval >= 2 && colAval.jobId) {
      var valsAval = shAval.getRange(2, colAval.jobId, lastAval-1, shAval.getLastColumn()).getValues();
      for (var i = 0; i < valsAval.length; i++) {
        if (canonId(valsAval[i][colAval.jobId-1]) === jobId) {
          // Encontrou a avaliação, pega a empresaId e audioUrl
          empresaId = colAval.empresaId ? valsAval[i][colAval.empresaId-1] : null;
          if (colAval.audioUrl || colAval.audio || colAval['Audio URL'] || colAval.linkAudio) {
            var audioCol = colAval.audioUrl || colAval.audio || colAval['Audio URL'] || colAval.linkAudio;
            audioUrl = valsAval[i][audioCol-1] || null;
          }
          break;
        }
      }
    }

    // Verifica se tem áudio
    if (audioUrl && String(audioUrl).trim() !== '') {
      status.audioSubmitted = true;
      status.audioUrl = String(audioUrl).trim();
    }

    // 2. Verifica se formulário foi preenchido (busca nas abas das empresas por jobId)
    status.debug.empresaId = empresaId;
    if (empresaId) {
      var ss = SpreadsheetApp.openById(SPREADSHEET_ID);
      var sheets = ss.getSheets();
      var targetSheetName = 'SM_' + empresaId;
      status.debug.targetSheetName = targetSheetName;
      
      // Procura especificamente pela aba SM_<empresaId>
      for (var s = 0; s < sheets.length; s++) {
        var sheet = sheets[s];
        var sheetName = sheet.getName();
        
        // Verifica se é a aba da empresa (padrão SM_<id>)
        if (sheetName !== targetSheetName) {
          continue;
        }
        
        status.debug.sheetFound = true;
        var lastRow = sheet.getLastRow();
        if (lastRow < 2) continue;
        
        try {
          var headerRange = sheet.getRange(1, 1, 1, sheet.getLastColumn());
          var headers = headerRange.getValues()[0];
          
          // Procura coluna job_id (com underscore)
          var jobIdCol = -1;
          for (var h = 0; h < headers.length; h++) {
            var header = String(headers[h] || '').toLowerCase().trim();
            if (header === 'job_id' || header === 'jobid' || header === 'job id') {
              jobIdCol = h + 1;
              break;
            }
          }
          
          if (jobIdCol > 0) {
            var jobIds = sheet.getRange(2, jobIdCol, lastRow-1, 1).getValues();
            for (var j = 0; j < jobIds.length; j++) {
              if (canonId(jobIds[j][0]) === jobId) {
                status.formSubmitted = true;
                break;
              }
            }
          }
        } catch(e) {
          // Ignora erros na aba da empresa
          status.debug.error = e.toString();
        }
        
        // Para após verificar a aba da empresa específica
        break;
      }
    }

    return status;

  } catch(e) {
    return { result:'error', message: e.toString() };
  }
}

function admin_getEvaluationStatus(p){ return admin_getEvaluationStatus_(p); }
function admin_listCompanies(){ return admin_listCompanies_(); }
function admin_upsertCompany(payload){ return admin_upsertCompany_(payload); }
function admin_assignEvaluation(payload){ return admin_assignEvaluation_(payload); }
function admin_userSummary(email){ return admin_userSummary_(email); }
function admin_checkConflicts(payload){ return admin_checkConflicts_(payload); }

/* ===================================================================
 *       SURVEYMONKEY → PLANILHA → STATUS "Concluída"
 * =================================================================== */
function getAvaliacoesSheet_(){ const ss=SpreadsheetApp.openById(SPREADSHEET_ID); const sh=ss.getSheetByName('AvaliacoesAtribuidas'); if(!sh) throw new Error('Aba AvaliacoesAtribuidas não encontrada.'); return sh; }
function getRedeemsSheet_(){ const ss=SpreadsheetApp.openById(SPREADSHEET_ID); let sh=ss.getSheetByName('PartnerVoucherRedeems'); if(!sh){ sh=ss.insertSheet('PartnerVoucherRedeems'); sh.appendRow(['code','jobId','estabelecimento','redeemed_at','partner_email','rating','ratingObs']); } else if (sh.getLastRow()===0){ sh.appendRow(['code','jobId','estabelecimento','redeemed_at','partner_email','rating','ratingObs']); } return sh; }
function getHeaderMap_(sh) {
  const headers=sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const aliases={
    empresaId:['empresaid','idempresa','empresa','companyid'],
    jobId:['jobid','id','job'],
    avaliadorEmail:['avaliadoremail','emailavaliador','emailav','avaliador','email'],
    nomeAvaliador:['nomeavaliador','avaliadornome','nome_avaliador'], // <<< ADICIONADO
    avaliadorNome:['avaliadornome','nomeavaliador','avaliador_nome'],  // <<< NOVO (sinônimo)
    estabelecimento:['estabelecimento','loja','unidade','nomeestabelecimento','empresa'],
    empresaNome:['empresanome','empresa_nome','nomeempresa','estabelecimento','empresa','loja','unidade'], // <<< NOVO
    endereco:['endereco','endereço','address','logradouro'],
    cidade:['cidade','municipio','cidadeuf','city'],
    uf:['uf','estado','sigla','state'],
    latitude:['latitude','lat'],
    longitude:['longitude','lng','long','lon'],
    dataISO:['dataiso','data','datayyyymmdd'],
    hora:['hora','horario','time'],
    periodo:['periodo','período','turno'],
    pdfPadraoURL:['pdfpadraourl','pdfpadrao','padraourl','pdf'],
    formularioURL:['formulariourl','formurl','surveyurl','surveymonkey','formulario'],
    voucherValor:['vouchervalor','valorvoucher','valor','reembolso'],
    // Ajuste: remover alias genérico 'voucher' que conflita com valor
    // e adicionar variantes comuns para o código do voucher
    voucherCodigo:['vouchercodigo','codigovoucher','codvoucher','codigo','código'],
    status:['status','situacao','situacaoavaliacao'],
    observacoes:['observacoes','observacoesopcional','obs','observacao','observaçoes'],
    instagram:['instagram','ig'],
    site:['site','website','urlsite'],
    telefoneEstab:['telefoneestab','telefone','tel','telefoneestabelecimento','fone'],
    surveyRespondentId:['surveyrespondentid','respondentid','sm_respondent_id','smrespondentid'],
    dataConclusao:['dataconclusao','conclusao','conclusão','finishedat','completedat'],
    audioUrl:['audiourl','audio','linkaudio','audiolink','url_audio','audio_url'],
    audioUploadedAt:['audiosentat','audiouploadedat','audio_enviado_em','audio_at','uploaded_at_audio']
  };
  const hmap={}; headers.forEach((h,idx)=>{ hmap[_norm_(h)]=idx+1; });
  const col={}; Object.keys(aliases).forEach(key=>{
    for (const a of aliases[key]) {
      const hit=hmap[a];
      if(hit){ col[key]=hit; break; }
    }
  });
  return col;
}

function mapRowToEvaluation_(row,col){
  const get=c=>(c?row[c-1]:'');
  return {
    empresaId:String(get(col.empresaId)||''),
    jobId:String(get(col.jobId)||''),
    avaliadorEmail:String(get(col.avaliadorEmail)||'').toLowerCase().trim(),
    nomeAvaliador:String(get(col.nomeAvaliador)||''),   // <<< ADICIONADO
    avaliadorNome: String(get(col.avaliadorNome||col.nomeAvaliador)||''), // espelho
    empresaNome: String(get(col.empresaNome||col.estabelecimento)||''),
    estabelecimento:String(get(col.estabelecimento)||''),
    endereco:String(get(col.endereco)||''),
    cidade:String(get(col.cidade)||''),
    uf:String(get(col.uf)||''),
    latitude:get(col.latitude)!==''?Number(get(col.latitude)):null,
    longitude:get(col.longitude)!==''?Number(get(col.longitude)):null,
    dataISO:String(get(col.dataISO)||''),
    hora:String(get(col.hora)||''),
    periodo:String(get(col.periodo)||''),
    pdfPadraoURL:String(get(col.pdfPadraoURL)||''),
    formularioURL:String(get(col.formularioURL)||''),
    voucherValor:get(col.voucherValor)!==''?Number(get(col.voucherValor)):0,
    voucherCodigo:String(get(col.voucherCodigo)||''),
    status:String(get(col.status)||'Pendente'),
    observacoes:String(get(col.observacoes)||''),
    instagram:String(get(col.instagram)||''),
    site:String(get(col.site)||''),
    telefoneEstab:String(get(col.telefoneEstab)||''),
    audioUrl:String(get(col.audioUrl)||''),
    audioUploadedAt:get(col.audioUploadedAt)||''
  };
}
function getHeaderMapRedeems_(sh){
  const headers=sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const aliases={ code:['code','codigo','código','voucher','vouchercodigo'], jobId:['jobid','job','id'],
    estabelecimento:['estabelecimento','loja','unidade'], redeemed_at:['redeemed_at','redeemedat','quando','datahora'],
    partner_email:['partner_email','partneremail','emailparceiro'], rating:['rating','nota','stars','estrelas'],
    ratingObs:['ratingobs','obs','observacao','observações','comentario','comment'] };
  const hmap={}; headers.forEach((h,i)=>hmap[_norm_(h)]=i+1);
  const col={}; Object.keys(aliases).forEach(k=>{ for(const a of aliases[k]){ const hit=hmap[a]; if(hit){ col[k]=hit; break; } } });
  return col;
}
function getRedeemsMap_(){
  const sh=getRedeemsSheet_(); const last=sh.getLastRow(); if(last<2) return {};
  const col=getHeaderMapRedeems_(sh); const values=sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  const out={}; for(let i=0;i<values.length;i++){ const r=values[i]; const code=String(col.code?r[col.code-1]:'').trim().toLowerCase(); if(!code) continue;
    out[code]={ redeemedAt:col.redeemed_at?r[col.redeemed_at-1]:'', redeemedBy:col.partner_email?String(r[col.partner_email-1]||''):'',
                rating:col.rating?Number(r[col.rating-1]||0):null, ratingObs:col.ratingObs?String(r[col.ratingObs-1]||''):'' }; }
  return out;
}
function listEvaluations_(email){
  const sh=getAvaliacoesSheet_(); const last=sh.getLastRow(); if(last<2) return [];
  const col=getHeaderMap_(sh); const values=sh.getRange(2,1,last-1,sh.getLastColumn()).getValues(); const lower=String(email||'').toLowerCase().trim(); if(!lower) return [];
  const redeemMap=getRedeemsMap_();
  return values.map(r=>mapRowToEvaluation_(r,col)).filter(v=>v.avaliadorEmail===lower).map(v=>{
    const red=v.voucherCodigo ? redeemMap[String(v.voucherCodigo).toLowerCase()] : null;
    return { jobId:v.jobId, estabelecimento:v.estabelecimento, dataISO:v.dataISO, hora:v.hora, periodo:v.periodo, cidade:v.cidade, uf:v.uf, status:v.status,
             rating: red && typeof red.rating==='number' && !isNaN(red.rating) ? red.rating : null, ratingComment: red ? (red.ratingObs || '') : '' };
  });
}
function getEvaluation_(jobId){
  const sh=getAvaliacoesSheet_(); const last=sh.getLastRow(); if(last<2) return null;
  const col=getHeaderMap_(sh); const values=sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  const found=values.map(r=>mapRowToEvaluation_(r,col)).find(v=>String(v.jobId)===String(jobId)); if(!found) return null;
  const redeemMap=getRedeemsMap_(); const red=found.voucherCodigo ? redeemMap[String(found.voucherCodigo).toLowerCase()] : null;
  const qrPayload={ jobId:found.jobId, avaliadorEmail:found.avaliadorEmail, estabelecimento:found.estabelecimento, dataISO:found.dataISO, hora:found.hora, periodo:found.periodo, voucherCodigo:found.voucherCodigo };
  return { ...found, qrPayload, rating: red && typeof red.rating==='number' && !isNaN(red.rating) ? red.rating : null, ratingComment: red ? (red.ratingObs || '') : '' };
}

/* ========= Voucher Status (libera o “Abrir Formulário”) ========= */
function voucherStatus_(codeRaw) {
  const code = String(codeRaw || '').trim();
  if (!code) return json({ result: 'error', message: 'Código obrigatório', version: VERSION });

  const shA = getAvaliacoesSheet_();
  const colA = getHeaderMap_(shA);
  const last = shA.getLastRow();
  if (last < 2 || !colA.voucherCodigo)
    return json({ result: 'not_found', message: 'Sem avaliações ou coluna voucher', version: VERSION });

  // procura pelo voucher (case-insensitive)
  const vals = shA.getRange(2, colA.voucherCodigo, last - 1, 1).getValues().flat();
  const idx = vals.findIndex(v => String(v).trim().toLowerCase() === code.toLowerCase());
  if (idx === -1) return json({ result: 'not_found', message: 'Voucher não encontrado', version: VERSION });

  const row = idx + 2;
  const rec = mapRowToEvaluation_(shA.getRange(row, 1, 1, shA.getLastColumn()).getValues()[0], colA);

  // status efetivo
  let status = String(rec.status || '').trim() || 'Pendente';
  const tz = Session.getScriptTimeZone();
  const todayISO = Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');
  let expired = false;

  if (status.toLowerCase() === 'pendente' && rec.dataISO) {
    expired = String(rec.dataISO) < todayISO; // compara 'YYYY-MM-DD'
    if (expired) {
      status = 'Expirada';
      if (colA.status) { try { shA.getRange(row, colA.status).setValue('Expirada'); } catch (_) {} }
    }
  }
  const isDone = status.toLowerCase() === 'concluída';

  // resgate (informativo)
  const redeemMap = getRedeemsMap_();
  const red = rec.voucherCodigo ? (redeemMap[String(rec.voucherCodigo).toLowerCase()] || null) : null;
  const redeemed = !!(red && red.redeemedAt);

  // URL do formulário (linha > empresa)
  let formUrl = rec.formularioURL || '';
  if (!formUrl && rec.empresaId) {
    try {
      const emp = admin_getCompanyById_(rec.empresaId);
      if (emp && emp.formularioURL) formUrl = String(emp.formularioURL);
    } catch (_) {}
  }

  const canOpen = (status.toLowerCase() === 'pendente') && !!formUrl;

  return json({
    result: 'ok',
    voucher: rec.voucherCodigo,
    jobId: rec.jobId,
    status,
    // >>> campos esperados pelo app <<<
    redeemed,
    redeemedAt: red ? red.redeemedAt || null : null,
    redeemedBy: red ? red.redeemedBy || null : null,
    // ---------------------------------
    canOpen,
    formUrl,
    reason: canOpen ? '' :
      (isDone ? 'already_completed' :
       expired ? 'expired' :
       !formUrl ? 'missing_form_url' :
       redeemed ? 'already_redeemed' : 'blocked'),
    meta: {
      empresaId: rec.empresaId,
      estabelecimento: rec.estabelecimento,
      dataISO: rec.dataISO,
      hora: rec.hora,
      periodo: rec.periodo,
      voucherValor: rec.voucherValor
    },
    version: VERSION
  });
}

/* === SM_Sources – build/scan === */
function sm_getSmSourcesSheet_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName('SM_Sources');
  if (!sh) { sh = ss.insertSheet('SM_Sources'); sh.appendRow(['empresaId','tabName','lastProcessedRow','voucherHeader','jobIdHeader','userEmailHeader','empresaIdHeader','respondentIdHeader']); }
  else if (sh.getLastRow() === 0) { sh.appendRow(['empresaId','tabName','lastProcessedRow','voucherHeader','jobIdHeader','userEmailHeader','empresaIdHeader','respondentIdHeader']); }
  return sh;
}
function sm_listSources_(){
  const sh = sm_getSmSourcesSheet_();
  const last = sh.getLastRow();
  if (last < 2) return [];
  const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  return vals.map((r,i)=>({
    row: i+2, empresaId: String(r[0]||'').trim(), tabName: String(r[1]||'').trim(), lastProcessedRow: Number(r[2]||0),
    voucherHeader: String(r[3]||'').trim(), jobIdHeader: String(r[4]||'').trim(), userEmailHeader: String(r[5]||'').trim(), empresaIdHeader: String(r[6]||'').trim(), respondentIdHeader: String(r[7]||'').trim()
  }));
}
function sm_upsertSource_(payload){
  let { empresaId, tabName, voucherHeader, jobIdHeader, userEmailHeader, empresaIdHeader, respondentIdHeader } = payload || {};
  empresaId = String(empresaId||'').trim(); tabName = String(tabName||'').trim();
  if (!empresaId || !tabName) return { result:'error', message:'empresaId e tabName obrigatórios', version: VERSION };
  const sh = sm_getSmSourcesSheet_(); const list = sm_listSources_(); const hit = list.find(x => x.empresaId === empresaId);
  if (hit) {
    const r = hit.row;
    sh.getRange(r,2).setValue(tabName);
    if (voucherHeader != null)      sh.getRange(r,4).setValue(String(voucherHeader||''));
    if (jobIdHeader != null)        sh.getRange(r,5).setValue(String(jobIdHeader||''));
    if (userEmailHeader != null)    sh.getRange(r,6).setValue(String(userEmailHeader||''));
    if (empresaIdHeader != null)    sh.getRange(r,7).setValue(String(empresaIdHeader||''));
    if (respondentIdHeader != null) sh.getRange(r,8).setValue(String(respondentIdHeader||''));
  } else {
    sh.appendRow([ empresaId, tabName, 0, String(voucherHeader||''), String(jobIdHeader||''), String(userEmailHeader||''), String(empresaIdHeader||''), String(respondentIdHeader||'') ]);
  }
  return { result:'ok', version: VERSION };
}
/* Garantias e índices */
function sm_requireEvalColumns_(shA, col){
  function ensure(name){
    if (!col[name]) { var lc = shA.getLastColumn(); shA.insertColumnAfter(lc); shA.getRange(1, lc + 1).setValue(name); col[name] = lc + 1; }
  }
  ensure('status'); ensure('dataConclusao'); ensure('surveyRespondentId'); ensure('audioUrl'); ensure('audioUploadedAt');
}
function sm_buildEvalIndexes_(){
  const shA = getAvaliacoesSheet_();
  const col = getHeaderMap_(shA);
  sm_requireEvalColumns_(shA, col);
  const last = shA.getLastRow();
  const byVoucher = {}, byJob = {}, byEmailEmpPending = {};
  if (last >= 2){
    const rows = shA.getRange(2,1,last-1,shA.getLastColumn()).getValues();
    for (let i=0;i<rows.length;i++){
      const map = mapRowToEvaluation_(rows[i], col);
      const rowNum = i+2;
      if (map.voucherCodigo) byVoucher[String(map.voucherCodigo).trim().toLowerCase()] = rowNum;
      if (map.jobId)         byJob[String(map.jobId).trim()] = rowNum;
      const st = String(map.status||'').toLowerCase();
      const isPending = st !== 'concluída' && st !== 'expirada';
      if (isPending && map.avaliadorEmail && map.empresaId){ byEmailEmpPending[`${map.avaliadorEmail}::${map.empresaId}`] = rowNum; }
    }
  }
  return { shA, col, byVoucher, byJob, byEmailEmpPending };
}
function _smNormHeader_(s){
  return String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase().replace(/\s+/g,' ').trim();
}
function sm_guessColIndex_(headers, opts){
  const H = headers.map(h => String(h||'')), Hn = H.map(_smNormHeader_);
  const clean = s => _smNormHeader_(s);
  if (opts.preferred){ const i = H.findIndex(h => String(h) === String(opts.preferred)); if (i !== -1) return i+1; }
  for (const fb of (opts.fallbacks||[])){ const j = H.findIndex(h => String(h) === String(fb)); if (j !== -1) return j+1; }
  const token = clean(opts.token||''); let k = -1;
  for (let idx=0; idx<Hn.length; idx++){
    const s = Hn[idx]; const tokenHit = s.includes(token) || s.replace(/[_:]/g,' ').includes(token);
    if (!tokenHit) continue; if (opts.requireCustomVar && !(s.includes('custom variable')||s.includes('variavel personalizada'))) continue; k = idx; break;
  }
  if (k !== -1) return k+1; const k2 = Hn.findIndex(s => s === token); if (k2 !== -1) return k2+1; return null;
}

/**
 * Lê uma linha da aba do Survey (tabName) como RECORD { "Pergunta": "Resposta" }.
 * Usa respondentId quando disponível; senão tenta jobId/voucher se fornecidos.
 */
function ai_buildRecordFromSurvey_(tabName, respondentId, jobId, voucher) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(tabName);
  if (!sh) throw new Error('Aba de respostas não encontrada: ' + tabName);
  const last = sh.getLastRow();
  if (last < 2) throw new Error('Aba sem respostas: ' + tabName);
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0].map(String);

  // Tenta localizar a linha pelo respondentId
  let cResp = sm_guessColIndex_(headers, { preferred: null, fallbacks: ['Respondent ID','ID do respondente','Identificador do respondente'], token:'respondent id' });
  let targetRow = null;

  function findRowByColExact(colIdx, value) {
    if (!colIdx || !value) return null;
    const vals = sh.getRange(2, colIdx, last-1, 1).getValues().flat();
    const idx  = vals.findIndex(v => String(v).trim() === String(value).trim());
    return idx === -1 ? null : (idx + 2);
  }

  targetRow = targetRow || findRowByColExact(cResp, respondentId);

  // fallback 1: tenta por jobId
  if (!targetRow && jobId) {
    const cJob = sm_guessColIndex_(headers, { preferred: null, fallbacks: ['Custom Variable: job_id','Variável personalizada: job_id','Job ID','jobId','job id','job_id'], token:'job id' });
    targetRow = findRowByColExact(cJob, jobId);
  }
  // fallback 2: tenta por voucher
  if (!targetRow && voucher) {
    const cVoucher = sm_guessColIndex_(headers, { preferred: null, fallbacks: ['Custom Variable: voucher','Variável personalizada: voucher','voucher','Voucher'], token:'voucher' });
    targetRow = findRowByColExact(cVoucher, voucher);
  }
  // fallback 3: última linha
  if (!targetRow) targetRow = last;

  const rowVals = sh.getRange(targetRow, 1, 1, sh.getLastColumn()).getValues()[0];
  const record = {};
  for (var c = 0; c < headers.length; c++) {
    const key = String(headers[c] || '').trim();
    if (!key) continue;
    record[key] = rowVals[c];
  }
  return record;
}

/**
 * Encontra a linha na aba AvaliacoesAtribuidas e retorna um objeto com campos úteis.
 */
function ai_getEvalRow_(rowA) {
  const shA = getAvaliacoesSheet_();
  const colA = getHeaderMap_(shA);
  const lastA = shA.getLastRow();
  if (rowA < 2 || rowA > lastA) throw new Error('Linha inválida em AvaliacoesAtribuidas: ' + rowA);
  const vals = shA.getRange(rowA, 1, 1, shA.getLastColumn()).getValues()[0];
  const rec  = mapRowToEvaluation_(vals, colA);
  return { shA, colA, rec };
}
/* Processa UMA fonte */
function sm_processSource_(src){
  const { shA, col, byVoucher, byJob, byEmailEmpPending } = sm_buildEvalIndexes_();
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(src.tabName);
  if (!sh) return { result:'error', message:'Aba não encontrada: '+src.tabName };
  const last = sh.getLastRow(); if (last < 2) return { result:'ok', scanned:0, updated:0, lastRow:last };
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];

  const cVoucher = sm_guessColIndex_(headers, { preferred: src.voucherHeader, fallbacks: ['Custom Variable: voucher','Variável personalizada: voucher','Custom Variables: voucher','voucher','Voucher'], token:'voucher' });
  const cJob     = sm_guessColIndex_(headers, { preferred: src.jobIdHeader,   fallbacks: ['Custom Variable: job_id','Variável personalizada: job_id','Custom Variable: job id','Job ID','jobId','job_id','job id'], token:'job id' });
  const cUser    = sm_guessColIndex_(headers, { preferred: src.userEmailHeader,fallbacks: ['Custom Variable: user_email','Variável personalizada: user_email','Email Address','E-mail','Endereço de e-mail','user_email','user email'], token:'user email' });
  const cEmp     = sm_guessColIndex_(headers, { preferred: src.empresaIdHeader,fallbacks: ['Custom Variable: empresaId','Variável personalizada: empresaId','empresaId','empresa id','companyid','company id'], token:'empresaid' });
  const cResp    = sm_guessColIndex_(headers, { preferred: src.respondentIdHeader,fallbacks:['Respondent ID','ID do respondente','Identificador do respondente'], token:'respondent id' });

  const shS = sm_getSmSourcesSheet_();
  if (!src.voucherHeader && cVoucher)      shS.getRange(src.row,4).setValue(String(headers[cVoucher-1]));
  if (!src.jobIdHeader   && cJob)          shS.getRange(src.row,5).setValue(String(headers[cJob-1]));
  if (!src.userEmailHeader && cUser)       shS.getRange(src.row,6).setValue(String(headers[cUser-1]));
  if (!src.empresaIdHeader && cEmp)        shS.getRange(src.row,7).setValue(String(headers[cEmp-1]));
  if (!src.respondentIdHeader && cResp)    shS.getRange(src.row,8).setValue(String(headers[cResp-1]));

  if (!cVoucher && !cJob && !cUser) {
    Logger.log('[SM] %s → Não achei colunas voucher/job_id/email. Headers: %s', src.tabName, JSON.stringify(headers));
    return { result:'ok', scanned:0, updated:0, lastRow:last, warn:'columns_not_found' };
  }

  const startRow = Math.max(2, Number(src.lastProcessedRow||0) + 1);
  if (startRow > last) return { result:'ok', scanned:0, updated:0, lastRow:last };

  const rows = sh.getRange(startRow,1,last-startRow+1,sh.getLastColumn()).getValues();
  let scanned = 0, updated = 0;

  for (let i=0;i<rows.length;i++){
    scanned++;
    const r = rows[i];
    const voucher = cVoucher ? String(r[cVoucher-1]||'').trim() : '';
    const jobId   = cJob     ? String(r[cJob-1]||'').trim()     : '';
    const email   = cUser    ? String(r[cUser-1]||'').trim().toLowerCase() : '';
    const empId   = cEmp     ? String(r[cEmp-1]||'').trim()     : String(src.empresaId||'');
    const respId  = cResp    ? String(r[cResp-1]||'').trim()    : '';

    let rowA = null;
    if (voucher) rowA = byVoucher[voucher.toLowerCase()] || null;
    if (!rowA && jobId) rowA = byJob[jobId] || null;
    if (!rowA && email && empId) { const key = `${email}::${empId}`; if (byEmailEmpPending[key]) rowA = byEmailEmpPending[key]; }
    if (!rowA) continue;

    const cur = String(shA.getRange(rowA, col.status).getValue()||'').toLowerCase();
    // Condição: só marca como concluída se houver áudio enviado
    const hasAudio = col.audioUrl ? String(shA.getRange(rowA, col.audioUrl).getValue()||'').trim() !== '' : false;
    if (respId && col.surveyRespondentId) { shA.getRange(rowA, col.surveyRespondentId).setValue(respId); }
    if (!hasAudio) {
      // mantém pendente até o áudio ser enviado
    } else if (cur !== 'concluída') {
      shA.getRange(rowA, col.status).setValue('Concluída');
      if (col.dataConclusao) shA.getRange(rowA, col.dataConclusao).setValue(new Date());
      updated++;
    }

    try { ai_hook_onConcluded_(empId || src.empresaId, src.tabName, shA, col, rowA, respId || ''); } catch(e){ Logger.log('[AI] enqueue fail: '+e); }
  }

  shS.getRange(src.row,3).setValue(last);
  Logger.log('[SM] %s → scanned=%s, updated=%s (lastRow=%s)', src.tabName, scanned, updated, last);
  return { result:'ok', scanned, updated, lastRow:last };
}
function sm_scanAll_(){
  const list = sm_listSources_(); let totalScanned = 0, totalUpdated = 0, count = 0; const reports = [];
  for (const s of list){ const rep = sm_processSource_(s); reports.push({ empresaId:s.empresaId, tabName:s.tabName, ...rep }); totalScanned += Number(rep.scanned||0); totalUpdated += Number(rep.updated||0); count++; }
  return { scanned: totalScanned, updated: totalUpdated, count, reports };
}
function sm_scanOne_(empresaIdOrTab){
  const list = sm_listSources_(); const s = list.find(x => x.empresaId === empresaIdOrTab || x.tabName === empresaIdOrTab);
  if (!s) return { result:'not_found' }; return sm_processSource_(s);
}

/* --- Menus / Gatilhos SM + IA --- */
function onOpen(){
  try{
    SpreadsheetApp.getUi()
      .createMenu('SuperSeller')
      .addItem('SurveyMonkey • Varrer tudo agora', 'sm_scanAll_')
      .addItem('SurveyMonkey • Instalar gatilho 15 min', 'sm_installTriggerEvery15min')
      .addItem('SurveyMonkey • Instalar gatilho 2 min', 'sm_installTriggerEvery2min')
      .addItem('SurveyMonkey • Instalar gatilho 1 min', 'sm_installTriggerEvery1min')
      .addToUi();
  } catch(_) {}
  try{
    SpreadsheetApp.getUi()
      .createMenu('IA')
      .addItem('Processar fila agora', 'ai_processQueue_')
      .addItem('Instalar gatilho (5 min)', 'ai_installQueueTriggerEvery5min')
      .addToUi();
  } catch(_) {}
}
function sm_installTriggerEvery15min(){ ScriptApp.getProjectTriggers().forEach(t=>{ if (t.getHandlerFunction() === 'sm_scanAll_') ScriptApp.deleteTrigger(t); }); ScriptApp.newTrigger('sm_scanAll_').timeBased().everyMinutes(15).create(); }
function sm_installTriggerEvery1min(){   ScriptApp.getProjectTriggers().forEach(t=>{ if (t.getHandlerFunction() === 'sm_scanAll_') ScriptApp.deleteTrigger(t); }); ScriptApp.newTrigger('sm_scanAll_').timeBased().everyMinutes(1).create(); }
function sm_installTriggerEvery2min(){   ScriptApp.getProjectTriggers().forEach(t=>{ if (t.getHandlerFunction() === 'sm_scanAll_') ScriptApp.deleteTrigger(t); }); ScriptApp.newTrigger('sm_scanAll_').timeBased().everyMinutes(2).create(); }
function sm_runNow(){ const rep = sm_scanAll_(); Logger.log(JSON.stringify(rep, null, 2)); }
function sm_scanAll(){ return sm_scanAll_(); }
function sm_scanOne_prompt(){ var id = Browser.inputBox('EmpresaId ou nome da aba SM_* a varrer:'); return sm_scanOne_(String(id || '').trim()); }

/* ===================================================================
 *                             IA (Análises)
 * =================================================================== */

 // --- IA config/context (modelo/temperatura) ---
var AI_LAST_CFG = null; // preenchido por ai_buildPrompt_ e lido por ai_callLLM_

const AI_METHOD_SPECS = (() => {
  const SERVIR_PILLARS = [
    {
      code: 'S',
      label: 'Saudação Estratégica',
      keywords: ['SAUDACAO', 'PRIMEIRA IMPRESSAO', 'DISPONIBILIDADE', 'APRESENTOU', 'APROXIMOU', 'ACOLHIMENTO']
    },
    {
      code: 'E',
      label: 'Exploração de Preferências',
      keywords: ['EXPLORACAO', 'PREFERENCIAS', 'OAR', 'OUVIR', 'ANOTAR', 'REFLETIR', 'VALIDOU']
    },
    {
      code: 'R_REC',
      label: 'Recomendação Personalizada',
      keywords: ['RECOMENDACAO', 'PERSONALIZADA', 'STORYTELLING', 'PROVA SOCIAL', 'OPCOES', 'SUGESTAO']
    },
    {
      code: 'V',
      label: 'Valorização da Experiência',
      keywords: ['VALORIZACAO', 'UPSELL', 'COMPLEMENTO', 'REGRA 60', 'OFERTA', 'ANTECIPOU']
    },
    {
      code: 'I',
      label: 'Implementação Impecável',
      keywords: ['IMPLEMENTACAO', 'IMPECAVEL', 'EXECUCAO', 'ENTREGA', 'ORGANIZACAO', 'PROMESSA', 'CUMPRI']
    },
    {
      code: 'R_REL',
      label: 'Retorno & Relacionamento',
      keywords: ['RETORNO', 'RELACIONAMENTO', 'AGRADECEU', 'CONVIDOU', 'FEEDBACK', 'RECORRENCIA', 'VOLTE']
    }
  ];

  return {
    ASDAC: {
      code: 'ASDAC',
      display: 'ASDAC',
      pillarOrder: ['AB', 'SO', 'DI', 'AD', 'CO'],
      pillarLabels: {
        AB: 'Abordagem',
        SO: 'Sondagem',
        DI: 'Diferencial',
        AD: 'Adicional',
        CO: 'Conclusão'
      },
      aspectCodes: ['AG'],
      aspectLabels: { AG: 'Aspectos Gerais' },
      weaknessFallback: ['AB','SO','DI','AD','CO'],
      frustrationFallback: ['SO','DI','CO'],
      html: {
        analiseTitle: 'Análise detalhada – ASDAC',
        tabelaTitle: 'Tabela ASDAC (nota + acerto %)'
      }
    },
    'SERVIR+GOLD': {
      code: 'SERVIR+GOLD',
      display: 'SERVIR + GOLD',
      pillarOrder: SERVIR_PILLARS.map(p => p.code),
      pillarLabels: SERVIR_PILLARS.reduce((acc, p) => { acc[p.code] = p.label; return acc; }, {}),
      aspectCodes: ['AG'],
      aspectLabels: { AG: 'Aspectos Gerais' },
      weaknessFallback: SERVIR_PILLARS.map(p => p.code),
      frustrationFallback: SERVIR_PILLARS.filter(p => p.code !== 'S').map(p => p.code),
      html: {
        analiseTitle: 'Análise detalhada – SERVIR + GOLD',
        tabelaTitle: 'Tabela SERVIR + GOLD (nota + acerto %)'
      },
      keywords: SERVIR_PILLARS,
      goldAttributes: {
        order: ['G','O','L','D'],
        labels: {
          G: 'Disponibilidade',
          O: 'Atenção',
          L: 'Compreensão',
          D: 'Proatividade'
        },
        keywords: {
          G: ['(G)', '[G]', '{G}', 'DISPONIBIL', 'DISPONIBILIDADE', 'DISPONIVEL'],
          O: ['(O)', '[O]', '{O}', 'ATENCAO', 'ATENTO', 'OUVIR'],
          L: ['(L)', '[L]', '{L}', 'COMPREENS', 'LEGITIMA', 'STORYTELLING', 'CONEXAO'],
          D: ['(D)', '[D]', '{D}', 'PROATIV', 'PROATIVIDADE', 'ANTECIP', 'DISPONIBILIZOU']
        }
      }
    }
  };
})();

function ai_getMetodoSpec_(metodo) {
  const key = String(metodo || '').toUpperCase();
  if (key && AI_METHOD_SPECS[key]) return AI_METHOD_SPECS[key];
  return AI_METHOD_SPECS['ASDAC'];
}

function ai_normalizeMetodo_(val) {
  const raw = String(val || '').trim();
  if (!raw) return 'SERVIR+GOLD';
  const norm = raw
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[^A-Z0-9+]+/gi, '')
    .toUpperCase();
  if (norm.indexOf('SERVIRGOLD') !== -1 || norm.indexOf('SERVIR+GOLD') !== -1) return 'SERVIR+GOLD';
  if (norm.indexOf('ASDAC') !== -1) return 'ASDAC';
  return raw.toUpperCase();
}

/** ======= Abas de configuração / fila / resultados ======= */
function ai_getConfigsSheet_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName('AI_Configs');
  // Cabeçalho esperado, incluindo 'assistantId'
  const headerColumns = ['empresaId','metodo','pdfFolderId','tabNameOverride','mapaPilaresJSON','npsHeader','nomeAvaliadoHeader','modelo','temp','maxTokens','useTools','assistantId'];
  if (!sh) {
    sh = ss.insertSheet('AI_Configs');
    sh.appendRow(headerColumns);
  } else if (sh.getLastRow() === 0) {
    sh.appendRow(headerColumns);
  } else {
    // Garante que 'assistantId' exista no cabeçalho (adiciona se não existir)
    const currentHeader = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(String);
    if (currentHeader.indexOf('assistantId') === -1) {
      // Adiciona a coluna ao final
      sh.insertColumnAfter(sh.getLastColumn());
      sh.getRange(1, sh.getLastColumn()).setValue('assistantId');
    }
  }
  return sh;
}
function ai_getQueueSheet_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName('AI_Queue');
  if (!sh) { sh = ss.insertSheet('AI_Queue'); sh.appendRow(['enqueuedAt','empresaId','tabName','jobId','voucher','user_email','respondentId','evalRow']); }
  else if (sh.getLastRow() === 0){ sh.appendRow(['enqueuedAt','empresaId','tabName','jobId','voucher','user_email','respondentId','evalRow']); }
  return sh;
}
function ai_getAnalisesSheet_(){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sh = ss.getSheetByName('AI_Analises');
  const header = ['createdAt','empresaId','metodo','jobId','voucher','user_email','data','avaliado','pilaresJSON','atributosGoldJSON','media','aspectosGerais','nps','pontosFortes','pontosFracos','planoAcao','pdfUrl','sentTo','sentAt'];
  if (!sh) {
    sh = ss.insertSheet('AI_Analises');
    sh.appendRow(header);
  } else if (sh.getLastRow() === 0){
    sh.appendRow(header);
  } else {
    const head = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(String);
    if (head.indexOf('atributosGoldJSON') === -1) {
      const pilaresIdx = head.indexOf('pilaresJSON');
      if (pilaresIdx !== -1) {
        const colNumber = pilaresIdx + 1; // 1-based column where pilaresJSON resides
        sh.insertColumnAfter(colNumber);
        sh.getRange(1, colNumber + 1).setValue('atributosGoldJSON');
      } else {
        const lastCol = sh.getLastColumn();
        sh.insertColumnAfter(lastCol);
        sh.getRange(1, lastCol + 1).setValue('atributosGoldJSON');
      }
    }
  }
  return sh;
}

/** ======= Config por empresa ======= */
function ai_getConfig_(empresaId){
  const sh = ai_getConfigsSheet_();
  const last = sh.getLastRow();
  if (last < 2) return {
    empresaId,
    metodo: 'SERVIR+GOLD',
    modelo: 'gpt-4o-mini',
    temp: 0.2,
    maxTokens: 1800,
    useTools: true,
    pdfFolderId: '', tabNameOverride: '', mapaPilaresJSON: '', npsHeader: '', nomeAvaliadoHeader: '',
    assistantId: ''
  };
  const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  const hit = vals.find(r => String(r[0])===String(empresaId));
  if (!hit) return {
    empresaId,
    metodo: 'SERVIR+GOLD',
    modelo: 'gpt-4o-mini',
    temp: 0.2,
    maxTokens: 1800,
    useTools: true,
    pdfFolderId: '', tabNameOverride: '', mapaPilaresJSON: '', npsHeader: '', nomeAvaliadoHeader: '',
    assistantId: ''
  };
  const metodo = ai_normalizeMetodo_(hit[1] || 'SERVIR+GOLD');
  const modelo = String(hit[7]||'').trim() || 'gpt-4o-mini';
  const temp = Number(hit[8]||0.2);
  const maxTokens = Number(hit[9]||1800);
  const useToolsRaw = String(hit[10]||'').trim().toLowerCase();
  const useTools = (useToolsRaw==='1' || useToolsRaw==='true' || useToolsRaw==='yes' || useToolsRaw==='sim');
  // Lê assistantId da coluna correta (índice 11)
  const assistantId = String(hit[11]||'').trim();
  return {
    empresaId,
    metodo,
    pdfFolderId: String(hit[2]||''),
    tabNameOverride: String(hit[3]||''),
    mapaPilaresJSON: String(hit[4]||''),
    npsHeader: String(hit[5]||''),
    nomeAvaliadoHeader: String(hit[6]||''),
    modelo, temp, maxTokens, useTools,
    assistantId
  };
}

/**
 * Aplica headers configurados (npsHeader, nomeAvaliadoHeader) sobre o meta,
 * extraindo valores do objeto "record" (mapa Pergunta->Resposta).
 * - Se encontrar npsHeader, tenta converter para número (aceita "8,5" -> 8.5).
 * - Se encontrar nomeAvaliadoHeader, define meta.avaliado (string).
 */
function ai_applyHeadersToMeta_(cfg, meta, record) {
  try {
    const safeMeta = meta || {};
    const rec = record || {};
    const keys = Object.keys(rec || {});

    // Normalizador (remove acentos, pontuação e espaços)
    function _nrm(s) {
      return String(s || '')
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    }

    // Procura por igualdade exata (case/acentos-insensitive)
    function findByExactHeader(header) {
      if (!header) return null;
      const target = _nrm(header);
      const hitKey = keys.find(k => _nrm(k) === target);
      return hitKey ? rec[hitKey] : null;
    }

    // Procura por tokens (contém), útil quando o header de config não foi preenchido
    function findByTokens(tokenList) {
      const tokens = (tokenList || []).map(_nrm).filter(Boolean);
      if (!tokens.length) return null;
      // encontra a primeira coluna cujo nome contenha TODOS os tokens informados
      const hitKey = keys.find(k => {
        const nk = _nrm(k);
        return tokens.every(t => nk.includes(t));
      });
      return hitKey ? rec[hitKey] : null;
    }

    // 1) NPS
    let npsRaw = null;
    // a) tenta header exato configurado
    npsRaw = npsRaw ?? findByExactHeader(cfg && cfg.npsHeader);
    // b) tenta heurísticas comuns (pt-br e abreviações)
    npsRaw = npsRaw ?? findByTokens(['nps']);
    npsRaw = npsRaw ?? findByTokens(['recomendaria']); // "Você recomendaria", etc.
    npsRaw = npsRaw ?? findByTokens(['probabilidade', 'recomendar']); // "Probabilidade de recomendar"
    npsRaw = npsRaw ?? findByTokens(['nota', '0', '10']); // "Nota (0-10)"

    if (npsRaw !== null && typeof npsRaw !== 'undefined' && String(npsRaw).trim() !== '') {
      // aceita "8,5" -> 8.5 ; "10" ; "7" ; mantém string se não for parseável
      const num = Number(String(npsRaw).replace(',', '.'));
      safeMeta.nps = (typeof num === 'number' && !isNaN(num)) ? num : String(npsRaw);
    }

    // 2) Nome do Avaliado (colaborador)
    let avalRaw = null;
    // a) tenta header exato configurado
    avalRaw = avalRaw ?? findByExactHeader(cfg && cfg.nomeAvaliadoHeader);
    // b) heurísticas de nomes frequentes
    avalRaw = avalRaw ?? findByTokens(['nome', 'avaliado']);
    avalRaw = avalRaw ?? findByTokens(['nome', 'colaborador']);
    avalRaw = avalRaw ?? findByTokens(['garcom']);      // "garçom" sem acento (normalizado)
    avalRaw = avalRaw ?? findByTokens(['garcao']);      // fallback raro (erros de digitação)
    avalRaw = avalRaw ?? findByTokens(['garçom']);      // caso o normalize falhe em algum ambiente
    avalRaw = avalRaw ?? findByTokens(['atendente']);
    avalRaw = avalRaw ?? findByTokens(['vendedor']);
    avalRaw = avalRaw ?? findByTokens(['barista']);
    avalRaw = avalRaw ?? findByTokens(['nome', 'funcionario']); // funcionário
    avalRaw = avalRaw ?? findByTokens(['nome', 'funcionaria']);

    if (avalRaw !== null && typeof avalRaw !== 'undefined' && String(avalRaw).trim() !== '') {
      safeMeta.avaliado = String(avalRaw).trim();
    }

    return safeMeta;
  } catch (e) {
    try { Logger.log('[ai_applyHeadersToMeta_] ' + e); } catch (_){}
    return meta || {};
  }
}
/**
 * Chama um Assistant (platform.openai.com → Assistants) e retorna o JSON estruturado.
 * Requer: Script property OPENAI_API_KEY e um assistantId válido na planilha AI_Configs.
 * Não usa tools; assume que o Assistant já está configurado com JSON Schema.
 */
function ai_callAssistant_v1_(assistantId, meta, record, buckets, negatives) {
  if (!assistantId) throw new Error('assistantId não informado');
  const key = (PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY')||'').trim();
  if (!key) throw new Error('OPENAI_API_KEY não configurada em Script Properties');

  const headers = { 'Authorization': 'Bearer ' + key, 'Content-Type': 'application/json' };

  // 1) Cria thread
  const thr = JSON.parse(UrlFetchApp.fetch('https://api.openai.com/v1/threads', {
    method: 'post', headers, payload: JSON.stringify({})
  }).getContentText() || '{}');

  // 2) Posta a mensagem com os dados (texto plano)
  const payloadText =
    'METADADOS:\\n' + JSON.stringify(meta) +
    '\\n\\nRESPOSTAS_BRUTAS:\\n' + JSON.stringify(record) +
    '\\n\\nMAPA_PILARES:\\n' + JSON.stringify(buckets) +
    '\\n\\nNEGATIVAS:\\n' + JSON.stringify(negatives);

  UrlFetchApp.fetch('https://api.openai.com/v1/threads/' + thr.id + '/messages', {
    method: 'post', headers,
    payload: JSON.stringify({ role: 'user', content: payloadText })
  });

  // 3) Executa o Assistant
  const run = JSON.parse(UrlFetchApp.fetch('https://api.openai.com/v1/threads/' + thr.id + '/runs', {
    method: 'post', headers, payload: JSON.stringify({ assistant_id: assistantId })
  }).getContentText() || '{}');

  // 4) Aguarda finalizar
  var status = run.status, runId = run.id, tries = 0;
  while (status === 'queued' || status === 'in_progress') {
    Utilities.sleep(1500);
    const r = JSON.parse(UrlFetchApp.fetch('https://api.openai.com/v1/threads/' + thr.id + '/runs/' + runId, { headers }).getContentText() || '{}');
    status = r.status;
    if (++tries > 60) throw new Error('Timeout ao aguardar a análise (Assistant)');
  }
  if (status !== 'completed') throw new Error('Execução do Assistant falhou: ' + status);

  // 5) Lê a última mensagem e retorna o JSON
  const msgs = JSON.parse(UrlFetchApp.fetch('https://api.openai.com/v1/threads/' + thr.id + '/messages?limit=1', { headers }).getContentText() || '{}');
  const content = (msgs.data && msgs.data[0] && msgs.data[0].content && msgs.data[0].content[0]) || null;
  const text = content && content.text && content.text.value ? content.text.value : '';
  if (!text) throw new Error('Sem conteúdo retornado pelo Assistant');
  return JSON.parse(text);
}

/**
 * Decide automaticamente entre Assistant (se houver assistantId) e o fluxo ai_callLLM_ atual.
 * Para usar, chame esta função no lugar onde hoje você monta o prompt e chama ai_callLLM_.
 */
function ai_generateReportWithConfig_(empresaId, metodo, meta, record, buckets, negatives, jsonSchema, promptTextIfNeeded) {
  const cfg = ai_getConfig_(empresaId);
  // Enriquecer meta a partir dos headers configurados (NPS e nome do avaliado)
  meta = ai_applyHeadersToMeta_(cfg, meta, record);
  try {
    const spec = ai_getMetodoSpec_(metodo);
    if (spec && spec.goldAttributes) {
      if (!meta || typeof meta !== 'object') meta = {};
      meta.goldBuckets = ai_groupHeadersByGold_(metodo, record);
      const detLocal = ai_computeDeterministico_(metodo, record, cfg || {});
      meta.atributosGold = detLocal.atributosGold || {};
    }
  } catch (eMetaGold) {
    try { Logger.log('[ai_generateReportWithConfig_] gold meta fail: ' + eMetaGold); } catch(_){}
  }
  if (cfg && cfg.assistantId) {
    return ai_callAssistant_v1_(cfg.assistantId, meta, record, buckets, negatives);
  }
  // Fallback para o caminho anterior baseado em prompt/json_schema:
  return ai_callLLM_(promptTextIfNeeded, jsonSchema, { model: cfg.modelo, temperature: cfg.temp, maxTokens: cfg.maxTokens, useTools: cfg.useTools });
}
function ai_enqueue_(empresaId, tabName, jobId, voucher, user_email, respondentId, evalRow){
  const sh = ai_getQueueSheet_();
  sh.appendRow([ new Date(), empresaId, tabName, jobId||'', voucher||'', user_email||'', respondentId||'', evalRow||'' ]);
}
function ai_hook_onConcluded_(empresaId, tabName, shA, col, rowA, respondentId){
  const get = (c) => c ? String(shA.getRange(rowA, c).getValue()||'') : '';
  const jobId   = get(col.jobId);
  const voucher = get(col.voucherCodigo);
  const email   = (get(col.avaliadorEmail)||'').toLowerCase();
  ai_enqueue_(empresaId, tabName, jobId, voucher, email, respondentId, rowA);
}
function ai_decideMethod_(empresaId){
  const cfg = ai_getConfig_(empresaId);
  return ai_normalizeMetodo_(cfg.metodo || 'SERVIR+GOLD');
}

/**
 * Processa a fila AI_Queue:
 * - Lê itens pendentes
 * - Monta RECORD a partir da aba de respostas (tabName)
 * - Enriquecer META com NPS e Avaliado via headers configurados
 * - Gera relatório com Assistant (ou fallback)
 * - Persiste em AI_Analises
 * - Remove item processado
 */
function ai_processQueue_() {
  const shQ = ai_getQueueSheet_();
  const last = shQ.getLastRow();
  if (last < 2) { Logger.log('[AI] Fila vazia'); return { result:'ok', processed:0 }; }

  const rows = shQ.getRange(2,1,last-1,shQ.getLastColumn()).getValues();
  const toDelete = [];
  let processed = 0, errors = 0;

  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const rowNum = i + 2;

    const enqueuedAt  = r[0];
    const empresaId   = String(r[1]||'').trim();
    const tabName     = String(r[2]||'').trim();
    const jobId       = String(r[3]||'').trim();
    const voucher     = String(r[4]||'').trim();
    const user_email  = String(r[5]||'').trim().toLowerCase();
    const respondentId= String(r[6]||'').trim();
    const evalRow     = String(r[7]||'').trim();

    if (!empresaId || !tabName) {
      Logger.log('[AI][skip] item inválido na linha %s (empresaId/tabName faltando)', rowNum);
      toDelete.push(rowNum);
      continue;
    }

    try {
      // ========= Build RECORD (Pergunta->Resposta) a partir da aba do Survey =========
      var record = {};
      try {
        record = ai_buildRecordFromSurvey_(tabName, respondentId, jobId, voucher);
      } catch (e1) {
        Logger.log('[AI][record] Falhou ao montar record de ' + tabName + ': ' + e1);
        record = {};
      }

      // ========= Meta básico =========
      var meta = {
        empresaId: empresaId,
        metodo: ai_decideMethod_(empresaId),
        jobId: jobId,
        voucher: voucher,
        user_email: user_email,
        data: new Date().toISOString()
      };

      // ========= Buckets (mapa de pilares) =========
      var cfg = ai_getConfig_(empresaId);
      var buckets = {};
      try { buckets = cfg.mapaPilaresJSON ? JSON.parse(cfg.mapaPilaresJSON) : {}; } catch (_) { buckets = {}; }

      // ========= Negatives (opcional) =========
      var negatives = {};
      (function initNegatives_(spec){
        const codes = (spec.pillarOrder || []).concat(spec.aspectCodes || []);
        for (var idx=0; idx<codes.length; idx++){
          negatives[codes[idx]] = [];
        }
      })(ai_getMetodoSpec_(meta.metodo));

      // ========= Enriquecer META com NPS / Avaliado =========
      meta = ai_applyHeadersToMeta_(cfg, meta, record);
      const detLocal = ai_computeDeterministico_(meta.metodo, record, cfg);
      meta.atributosGold = detLocal.atributosGold || {};
      meta.goldBuckets = ai_groupHeadersByGold_(meta.metodo, record);

      // ========= Gera o relatório (Assistant quando disponível) =========
      var schemaJSON = null;   // fallback somente
      var promptText = '';     // fallback somente
      var report = ai_generateReportWithConfig_(empresaId, ai_normalizeMetodo_(meta.metodo || 'SERVIR+GOLD'), meta, record, buckets, negatives, schemaJSON, promptText);

      // ========= Mescla com cálculo determinístico para garantir consistência =========
      try {
        report = report || {};
        const pilaresDet = detLocal.pilares || {};
        report.pilares = { ...(report.pilares || {}), ...pilaresDet };
        if (typeof detLocal.media === 'number') report.media = detLocal.media;
        if (detLocal.aspectosGerais != null) report.aspectosGerais = detLocal.aspectosGerais;
        if (detLocal.nps != null) report.nps = detLocal.nps;
        report.atributosGold = { ...(report.atributosGold || {}), ...(detLocal.atributosGold || {}) };
      } catch (mergeErr) {
        try { Logger.log('[AI] merge determinístico falhou: ' + mergeErr); } catch(_){}
      }

      // ========= Persistir na AI_Analises =========
      var shOut = ai_getAnalisesSheet_();
      var headersOut = shOut.getRange(1,1,1,shOut.getLastColumn()).getValues()[0].map(String);
      var colOut = {}; headersOut.forEach(function(h, idx){ colOut[h] = idx+1; });
      var outRow = shOut.getLastRow() + 1;
      shOut.insertRowsAfter(shOut.getLastRow(), 1);

      function _get(obj, path, dflt){
        try{
          var v = obj;
          path.split('.').forEach(function(k){ v = (v && (typeof v === 'object')) ? v[k] : undefined; });
          return (typeof v === 'undefined') ? dflt : v;
        } catch(_){ return dflt; }
      }

      var pilaresJSON = JSON.stringify(_get(report, 'pilares', {}));
      var atributosGoldJSON = JSON.stringify(_get(report, 'atributosGold', {}));
      var media = _get(report, 'media', '');
      var aspectosGerais = _get(report, 'aspectosGerais', '');
      var npsVal = _get(report, 'nps', meta.nps || '');
      var avaliadoVal = _get(report, 'avaliado', '') || meta.avaliado || '';

      var rowOut = new Array(shOut.getLastColumn()).fill('');
      rowOut[colOut['createdAt']-1] = new Date();
      rowOut[colOut['empresaId']-1] = String(empresaId||'');
      rowOut[colOut['metodo']-1] = String(meta.metodo||'SERVIR+GOLD');
      rowOut[colOut['jobId']-1] = String(jobId||'');
      rowOut[colOut['voucher']-1] = String(voucher||'');
      rowOut[colOut['user_email']-1] = String(user_email||'');
      rowOut[colOut['data']-1] = String(_get(report, 'data', meta.data||''));
      rowOut[colOut['avaliado']-1] = String(avaliadoVal||'');
      rowOut[colOut['pilaresJSON']-1] = pilaresJSON;
      var attrCol = colOut['atributosGoldJSON'] || colOut['atributosGold'];
      if (attrCol) {
        rowOut[attrCol-1] = atributosGoldJSON;
      }
      rowOut[colOut['media']-1] = media;
      rowOut[colOut['aspectosGerais']-1] = aspectosGerais;
      rowOut[colOut['nps']-1] = npsVal;
      rowOut[colOut['pontosFortes']-1] = JSON.stringify(_get(report, 'pontosFortes', []));
      rowOut[colOut['pontosFracos']-1] = JSON.stringify(_get(report, 'pontosFracos', []));
      rowOut[colOut['planoAcao']-1] = JSON.stringify(_get(report, 'planoAcao', []));
      // pdfUrl, sentTo, sentAt ficam para etapas posteriores

      shOut.getRange(outRow, 1, 1, rowOut.length).setValues([rowOut]);

      // marcar para remoção da fila
      toDelete.push(rowNum);
      processed++;
    } catch (e) {
      errors++;
      Logger.log('[AI][error] Linha %s: %s', rowNum, e);
      // Não remove da fila em erro; ficará para nova tentativa
    }
  }

  // Remove processados (de baixo para cima)
  toDelete.sort(function(a,b){ return b-a; }).forEach(function(r){ try { shQ.deleteRow(r); } catch(_){ } });

  return { result:'ok', processed: processed, errors: errors, removed: toDelete.length };
}

/** ======= Chamada ao LLM (OpenAI) – JSON-only ======= */
function ai_callLLM_(prompt, jsonSchema, opts){
  const key = (PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY')||'').trim();
  if (!key) return { _status: 'no_api_key' };

  // Prefer opts → cfg (AI_LAST_CFG) → defaults
  const cfg = AI_LAST_CFG || {};
  const model = (opts && opts.model) || cfg.modelo || 'gpt-4o-mini';
  const temperature = (opts && (typeof opts.temperature!=='undefined')) ? opts.temperature : (typeof cfg.temp!=='undefined' ? cfg.temp : 0.2);
  const max_tokens = (opts && opts.maxTokens) || cfg.maxTokens || 1800;
  const useTools = (opts && typeof opts.useTools!=='undefined') ? opts.useTools : (typeof cfg.useTools!=='undefined' ? cfg.useTools : true);

  // Try function-calling first (mais robusto), depois cai para json_object
  try {
    if (useTools && jsonSchema) {
      const fnSchema = (typeof jsonSchema === 'string') ? JSON.parse(jsonSchema) : jsonSchema;
      const bodyTools = {
        model, temperature, max_tokens,
        messages: [
          { role: 'system', content: 'Você responde via chamada de função, retornando apenas argumentos JSON.' },
          { role: 'user', content: prompt }
        ],
        tools: [{ type:'function', function:{ name:'build_report', parameters: fnSchema } }],
        tool_choice: { type:'function', function:{ name:'build_report' } }
      };
      const resT = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', {
        method: 'post', muteHttpExceptions: true,
        headers: { 'Content-Type':'application/json', 'Authorization':'Bearer '+key },
        payload: JSON.stringify(bodyTools),
      });
      const jsT = JSON.parse(resT.getContentText() || '{}');
      const toolCall = jsT.choices && jsT.choices[0] && jsT.choices[0].message && jsT.choices[0].message.tool_calls && jsT.choices[0].message.tool_calls[0];
      if (toolCall && toolCall.function && toolCall.function.name === 'build_report') {
        let out = {};
        try { out = JSON.parse(toolCall.function.arguments || '{}'); } catch(_) { out = {}; }
        const missing = ai_validateReport_(out);
        if (missing.length === 0) return out;

        // uma tentativa de reparo
        const repairMsg = `Faltaram os campos: ${missing.join(', ')}. Retorne SOMENTE a função build_report completa, preenchendo-os (mín. 2 itens em forças/fracas).`;
        bodyTools.messages.push({ role:'user', content: repairMsg });
        const resT2 = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', {
          method: 'post', muteHttpExceptions: true,
          headers: { 'Content-Type':'application/json', 'Authorization':'Bearer '+key },
          payload: JSON.stringify(bodyTools),
        });
        const jsT2 = JSON.parse(resT2.getContentText() || '{}');
        const toolCall2 = jsT2.choices && jsT2.choices[0] && jsT2.choices[0].message && jsT2.choices[0].message.tool_calls && jsT2.choices[0].message.tool_calls[0];
        if (toolCall2 && toolCall2.function && toolCall2.function.arguments) {
          try { return JSON.parse(toolCall2.function.arguments); } catch(_) {}
        }
      }
    }
  } catch (e) {
    try{ Logger.log('[AI] tools path failed: '+e); }catch(_){}
  }

  // Fallback: JSON-only (compatível com 4o-mini etc.)
  const bodyJson = {
    model, response_format: { type: 'json_object' }, temperature, max_tokens,
    messages: [
      { role: 'system', content: 'Você é um analista de atendimento. Responda APENAS com JSON válido conforme o schema fornecido.' },
      { role: 'user', content: prompt },
      { role: 'user', content: 'Schema JSON a ser seguido, campos obrigatórios. NUNCA inclua campos extras:\n' + jsonSchema }
    ]
  };
  const res = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', {
    method: 'post', muteHttpExceptions: true,
    headers: { 'Content-Type':'application/json', 'Authorization':'Bearer '+key },
    payload: JSON.stringify(bodyJson),
  });
  const txt = res.getContentText();
  let js = null; try { js = JSON.parse(txt); } catch { throw new Error('Resposta inválida do LLM'); }
  const msg = js.choices && js.choices[0] && js.choices[0].message && js.choices[0].message.content;
  if (!msg) throw new Error('Sem conteúdo na resposta do LLM');
  let out = null; try { out = JSON.parse(msg); } catch { throw new Error('LLM não retornou JSON válido'); }
  return out;
}

/** ======= Normalização / extração determinística dos pilares (ASDAC) ======= */
function ai_norm_(s){
  return String(s||'')
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/\s+/g,' ').trim().toLowerCase();
}
function ai_normU_(s){
  return ai_norm_(s).toUpperCase();
}

function ai_groupHeadersByPilar_(metodo, record){
  const spec = ai_getMetodoSpec_(metodo);
  const buckets = {};
  (spec.pillarOrder || []).forEach(code => { buckets[code] = []; });
  (spec.aspectCodes || []).forEach(code => { if (!buckets[code]) buckets[code] = []; });
  Object.keys(record||{}).forEach(h=>{
    const code = ai_pillarFromHeader_(metodo, h);
    if (!code) return;
    if (!buckets[code]) buckets[code] = [];
    buckets[code].push(h);
  });
  return buckets;
}

function ai_listNegativesByPilar_(metodo, record){
  const spec = ai_getMetodoSpec_(metodo);
  const out = {};
  (spec.pillarOrder || []).concat(spec.aspectCodes || []).forEach(code => { out[code] = []; });
  Object.keys(record||{}).forEach(h=>{
    const code = ai_pillarFromHeader_(metodo, h);
    if (!code) return;
    const a = ai_answer01_(record[h]);
    if (!out[code]) out[code] = [];
    if (a.count && a.v < 0.5) out[code].push(h);
  });
  return out;
}

/** Converte resposta para escala 0..1 respeitando regras:
 *  - "sim"=1, "não"=0
 *  - estrela 1..5 => 0.2,0.4,0.6,0.8,1.0
 *  - "ruim"=0, "bom"=0.5, "excelente"=1
 *  - "N/A", "não se aplica", vazio => {count:false} (não conta na média)
 */
function ai_answer01_(val){
  if (val === null || typeof val === 'undefined') return {count:false, v:0};
  if (typeof val === 'number') {
    if (val >= 0 && val <= 1) return {count:true, v:Number(val)};
    if (val >= 1 && val <= 5) return {count:true, v:Math.max(0, Math.min(1, val/5))};
  }
  const raw = String(val||'').trim();
  if (!raw) return {count:false, v:0};
  const s = ai_norm_(raw);
  // conta quantos "sim" e "não" aparecem quando há múltiplos subitens
  const simCount = (s.match(/\bsim\b/g) || []).length;
  const naoCount = (s.match(/\bn(?:a|ã)o\b/g) || []).length;
  if (simCount + naoCount >= 2) {
    return { count: true, v: simCount / (simCount + naoCount) };
  }

  // N/A
  // N/A / não se aplica
  if (/(^|\s)(n\/a|nao se aplica|não se aplica|sem avaliacao|sem avaliação)($|\s)/.test(s))
    return {count:false, v:0};

  // sim/não
  if (/^s+i+m\b/.test(s)) return {count:true, v:1};
  if (/^n(a|ã)o\b/.test(s)) return {count:true, v:0};

  // ruim / bom / excelente
  if (/excelente|otimo|ótimo|muito bom/.test(s)) return {count:true, v:1};
  if (/\bbom\b/.test(s)) return {count:true, v:0.5};
  if (/ruim|pessimo|péssimo|muito ruim/.test(s)) return {count:true, v:0};

  // estrelas em texto (ex.: "5 estrelas", "4/5", "★ 3")
  const mStar = s.match(/([1-5])\s*(estrel|star|\/\s*5|\/5)?/);
  if (mStar) {
    const n = Number(mStar[1]);
    if (n>=1 && n<=5) return {count:true, v:n/5};
  }

  // números isolados 0..10 já normalizados?
  const m = s.match(/\b([0-9]+(?:[.,][0-9]+)?)\b/);
  if (m) {
    const num = Number(m[1].replace(',','.'));
    if (!isNaN(num)) {
      if (num <= 1) return {count:true, v:Math.max(0, Math.min(1, num))};
      if (num >= 1 && num <= 5) return {count:true, v:Math.max(0, Math.min(1, num/5))};
      if (num > 5 && num <= 10) return {count:true, v:Math.max(0, Math.min(1, num/10))};
    }
  }
  return {count:false, v:0}; // desconhecido -> ignora
}
  
  function ai_answer01_multi_(val){
    // Se vier array, calcula média dos itens
    if (Array.isArray(val)) {
      let sum=0,cnt=0;
      for (const p of val) {
        const a=ai_answer01_(p);
        if(a.count){ sum+=a.v; cnt++; }
      }
      return cnt?{count:true,v:sum/cnt}:{count:false,v:0};
    }

    const s = String(val||'').trim();

    // NÃO quebrar frações do tipo "4/5"
    if (/\b[1-5]\s*\/\s*5\b/.test(s)) return ai_answer01_(s);

    // Quebra múltiplas respostas: "Sim | Não | Sim", "Sim;Não", etc.
    const parts = s.split(/\s*[|;,\/]+\s*/).filter(Boolean);
    if (parts.length <= 1) return ai_answer01_(val);

    let sum=0,cnt=0;
    for (const p of parts){
      const a=ai_answer01_(p);
      if(a.count){ sum+=a.v; cnt++; }
    }
    return cnt?{count:true,v:sum/cnt}:ai_answer01_(val);
  }
/** Extrai pilares por método a partir do cabeçalho (ex.: AB|SO|... ou S|E|...) */
function ai_extractPilaresFromRecord_(metodo, record){
  const M = String(metodo||'').toUpperCase();
  const spec = ai_getMetodoSpec_(M);
  const out = { pilares:{}, aspectosGerais:null };
  if (!record) return out;

  const sums = {};
  const counts = {};
  (spec.pillarOrder || []).concat(spec.aspectCodes || []).forEach(code => {
    sums[code] = 0;
    counts[code] = 0;
  });
  const goldSpec = spec.goldAttributes || null;
  const goldSums = {};
  const goldCounts = {};
  if (goldSpec && goldSpec.order) {
    goldSpec.order.forEach(code => { goldSums[code] = 0; goldCounts[code] = 0; });
  }

  Object.keys(record).forEach(h=>{
    const code = ai_pillarFromHeader_(M, h);
    if (!code) return;
    const {count, v} = ai_answer01_multi_(record[h]);
    if (!count) return;         // valores não-escala (comentários, URLs, telefones etc.) NÃO entram
    if (typeof sums[code] === 'undefined') {
      sums[code] = 0;
      counts[code] = 0;
    }
    sums[code]   += v;
    counts[code] += 1;

    if (goldSpec) {
      const tags = ai_detectGoldTags_(M, h);
      tags.forEach(tag=>{
        if (typeof goldSums[tag] === 'undefined') {
          goldSums[tag] = 0;
          goldCounts[tag] = 0;
        }
        goldSums[tag] += v;
        goldCounts[tag] += 1;
      });
    }
  });

  const to10 = (sum, cnt)=> cnt>0 ? +((sum/cnt)*10).toFixed(2) : null;

  const pilares = {};
  (spec.pillarOrder || []).forEach(k=>{
    const note = to10(sums[k], counts[k]);
    if (note !== null) pilares[k] = note;
  });

  out.pilares = pilares;
  if (spec.aspectCodes && spec.aspectCodes.length) {
    const agCode = spec.aspectCodes[0];
    const agNote = to10(sums[agCode], counts[agCode]);
    out.aspectosGerais = (agNote===null?null:agNote);
  }

  if (goldSpec) {
    const attrs = {};
    const order = goldSpec.order || Object.keys(goldSums);
    order.forEach(tag=>{
      const note = to10(goldSums[tag] || 0, goldCounts[tag] || 0);
      if (note !== null) attrs[tag] = note;
    });
    out.gold = attrs;
  }
  return out;
}

/** ======= Prompt / schema do LLM ======= */
function ai_buildPrompt_(metodo, meta, record, cfg){
  // Salva cfg para ai_callLLM_
  AI_LAST_CFG = cfg || null;

  const spec = ai_getMetodoSpec_(metodo);
  const methodDisplay = spec.display || String(metodo || '').toUpperCase();
  const pillarDisplayShort = (spec.pillarOrder || []).map(code => {
    const label = (spec.pillarLabels && spec.pillarLabels[code]) || code;
    if (code === 'R_REC') return 'R1 (Recomendação Personalizada)';
    if (code === 'R_REL') return 'R2 (Retorno & Relacionamento)';
    return `${code} (${label})`;
  });

  // buckets & negativos conforme lógica atual
  const buckets = ai_groupHeadersByPilar_(metodo, record);
  const negatives = ai_listNegativesByPilar_(metodo, record);
  const goldBuckets = ai_groupHeadersByGold_(metodo, record);

  // Cálculos determinísticos para estabilizar a saída (0..10)
  const det = ai_computeDeterministico_(metodo, record, cfg || {});
  const dadosFixos = {
    metodo: String(metodo || ''),
    pilares: det.pilares || {},
    media: det.media || 0,
    ranking: det.ranking || null,
    aspectosGerais: (typeof det.aspectosGerais==='number'?det.aspectosGerais:null),
    aspectosGeraisDetalhado: det.aspectosGeraisDetalhado || {},
    nps: (typeof det.nps==='number'?det.nps:null),
    atributosGold: det.atributosGold || {}
  };

  const metaStr = JSON.stringify(meta, null, 2);
  const recStr  = JSON.stringify(record, null, 2);

  // Mantém schema amplo (retrocompatível)
  const schema = {
    type: 'object',
    properties: {
      empresaId:{type:'string'}, metodo:{type:'string'}, jobId:{type:'string'}, voucher:{type:'string'}, user_email:{type:'string'},
      data:{type:'string'}, avaliado:{type:'string'},
      pilares:{type:'object', additionalProperties:{type:'number'}},
      media:{type:'number'},
      aspectosGerais:{type:['number','null']},
      nps:{type:['number','null']},
      pontosFortes:{type:'array',items:{type:'string'}},
      pontosFracos:{type:'array',items:{type:'string'}},
      planoAcao:{type:'array',items:{type:'object',properties:{acao:{type:'string'},prazoDias:{type:['number','null']},responsavel:{type:['string','null']}},required:['acao']}},
      sumarioExecutivo:{type:'object',properties:{notaGeralPercentual:{type:['number','null']},classificacaoRanking:{type:['string','null']},principaisFortes:{type:'array',items:{type:'string'}},principaisFracos:{type:'array',items:{type:'string'}},insightCentral:{type:['string','null']}}},
      analiseDetalhada:{type:'object',additionalProperties:{type:'object',properties:{comportamentos:{type:'array',items:{type:'string'}},impacto:{type:['string','null']},melhoria:{type:['string','null']}}}},
      aspectosGeraisDetalhado:{type:'object',properties:{higiene:{type:['number','null']},simpatia:{type:['number','null']},agilidade:{type:['number','null']},educacao:{type:['number','null']},atencao:{type:['number','null']},qualidadePratos:{type:['number','null']},variedadeBebidas:{type:['number','null']},preco:{type:['number','null']},ambiente:{type:['number','null']},satisfacoes:{type:'array',items:{type:'string'}},frustracoes:{type:'array',items:{type:'string'}}}},
      recomendacoesPraticas:{type:'object',properties:{garcom:{type:'array',items:{type:'string'}},gestor:{type:'array',items:{type:'string'}},horizonte:{type:'object',properties:{dias90:{type:'array',items:{type:'string'}},dias30:{type:'array',items:{type:'string'}},dias7:{type:'array',items:{type:'string'}}}}}},
      insightsEstrategicos:{type:'array',items:{type:'string'}},
      sinteseComentarios:{type:['string','null']},
      tabelaPilares:{type:'object',additionalProperties:{type:'object',properties:{nota:{type:['number','null']},percentual:{type:['number','null']}}}},
      atributosGold:{type:'object',additionalProperties:{type:['number','null']}},
      conclusao:{type:['string','null']}
    },
    required:['empresaId','metodo','jobId','voucher','user_email','pilares','media','pontosFortes','pontosFracos','planoAcao']
  };
  const schemaStr = JSON.stringify(schema, null, 2);

const mappingExample = spec.code === 'SERVIR+GOLD'
  ? 'ex.: upsell pertence à etapa V (Valorização).'
  : 'ex.: redes sociais é Sondagem.';

const methodologyGuidance = spec.code === 'SERVIR+GOLD'
  ? `Metodologia SERVIR + GOLD®:
- S — Saudação Estratégica: avalia primeira impressão, acolhimento e disponibilidade (G).
- E — Exploração de Preferências: use o O.A.R. (Ouvir, Anotar, Refletir) e valide necessidades.
- R1 — Recomendação Personalizada: conecte preferências às sugestões, use storytelling e prova social, destaque a compreensão (L).
- V — Valorização da Experiência: avalie upsell com a Regra 60-20-20, timing e proatividade (D).
- I — Implementação Impecável: execução correta, organização da mesa e cumprimento do prometido.
- R2 — Retorno & Relacionamento: fechamento humanizado, feedback, agradecimento e convite à recorrência.
Atributos GOLD: Disponibilidade (G), Atenção (O), Compreensão (L), Proatividade (D); cite-os quando surgirem nas respostas.`
  : `Metodologia ASDAC:
- AB — Abordagem: recepção inicial e ambientação.
- SO — Sondagem: uso de perguntas para entender necessidades.
- DI — Diferencial: demonstração de conhecimento e personalização.
- AD — Agregador: vendas adicionais/upsell coerente.
- CO — Conclusão: fechamento, convite ao retorno e despedida.`;

const analiseDetalhadaLine = spec.code === 'SERVIR+GOLD'
  ? `2. Análise Detalhada (${pillarDisplayShort.join(' / ')}): conecte comportamentos à jornada SERVIR e explique impacto em vendas/experiência, citando atributos GOLD quando aplicável.`
  : `2. Análise Detalhada (${pillarDisplayShort.join(' / ')}): impacto e melhoria com tom de coaching.`;

const prompt =
`📑 Instruções para Análise de Relatórios de Cliente Oculto – IA SuperSeller (${methodDisplay})

Contexto (metadados):
${metaStr}

DADOS FIXOS (NÃO ALTERE NEM RE-CALCULE):
${JSON.stringify(dadosFixos, null, 2)}

Respostas brutas do formulário (sem alterar texto):
${recStr}

Mapa de perguntas por pilar (use este mapa para NÃO misturar itens entre seções):
${JSON.stringify(buckets, null, 2)}

Perguntas com resposta negativa (use como base de fraquezas e frustrações):
${JSON.stringify(negatives, null, 2)}

Mapa de atributos GOLD (quando houver letras adicionais G/O/L/D nas perguntas):
${JSON.stringify(goldBuckets, null, 2)}

REGRAS DE CÁLCULO / CONSISTÊNCIA:
- As notas (pilares, média, NPS e aspectos) JÁ FORAM CALCULADAS e DEVEM SER USADAS COMO ESTÃO.
- Não mova observações entre pilares; ${mappingExample}
- Sempre preencha "frustrações" com base nas perguntas negativas quando existirem.
- Quando houver atributos GOLD mapeados, conecte-os explicitamente às recomendações e observações.

${methodologyGuidance}

1) Estrutura do Relatório
1. Sumário Executivo (refira-se às notas fixas; dê 1 insight central).
${analiseDetalhadaLine}
3. Aspectos Gerais (conectar itens a percepções do cliente).
4. Recomendações Práticas (garçom/gestor; ações curtas, acionáveis).
5. Conclusão (reforço e próximos passos).

2) Estilo: humanizado, conecte comportamento→impacto em vendas.

Responda SOMENTE com JSON válido conforme o schema.`;

  return { prompt, schemaStr };
}

/** ======= Lê uma linha SM e retorna headers + record ======= */
function ai_buildCaseFromSM_(empresaId, tabName, respondentId){
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh = ss.getSheetByName(tabName);
  if (!sh) throw new Error('Aba SM não encontrado: ' + tabName);
  const last = sh.getLastRow(); if (last < 2) throw new Error('Aba SM vazia: ' + tabName);
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0].map(String);
  const Hn = headers.map(h => h.toLowerCase().trim());
  let rowIdx = -1;
  if (respondentId) {
    const i = Hn.findIndex(h => h.includes('respondent id') || h.includes('id do respondente'));
    if (i !== -1) {
      const col = i+1, vals = sh.getRange(2,col,last-1,1).getValues().flat();
      const idx = vals.findIndex(v => String(v).trim() === String(respondentId));
      if (idx !== -1) rowIdx = idx + 2;
    }
  }
  if (rowIdx === -1) rowIdx = last;
  const values = sh.getRange(rowIdx,1,1,sh.getLastColumn()).getValues()[0];
  const record = {}; headers.forEach((h, i) => record[h] = values[i]);
  return { headers, record, row: rowIdx };
}

/** ======= Média (prioriza pilares ASDAC) ======= */

/** ======= Extrai o "avaliado" (nome da pessoa) a partir do record SM =======
 *  Regras:
 *   - Procurar campos cujo cabeçalho contenha GARÇOM/GARCOM, VENDEDOR ou ATENDENTE
 *   - Aceitar variações: "Nome do garçom", "garçom avaliado", "garçom", idem para vendedor/atendente
 *   - Tolerar prefixos como "Q4.", "Q12)"
 *   - Ignorar valores vazios, "n/a", "não sei", etc.
 *   - Nunca retornar o nome do estabelecimento/empresa
 *   - Preferência de escolha: Garçom > Vendedor > Atendente; dentro do papel, prioriza cabeçalhos com "nome"/"avaliado"
 */
function ai_extractAvaliadoFromRecord_(record, estabelecimento){
  function norm(s){
    return String(s||'')
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .toLowerCase().replace(/\s+/g,' ').trim();
  }
  function cleanHeader(h){
    var s = norm(h)
      .replace(/^custom (variable|variables):\s*/i,'')
      .replace(/^q\d+[.)-]?\s*/i,''); // remove "Q4.", "Q12) ", etc.
    return s;
  }
  var estNorm = norm(estabelecimento||'');
  function isBadValue(v){
  var s = norm(v);
  if (!s) return true;
  if (s == estNorm) return true; // é o próprio nome do estabelecimento

  // n/a | nao se aplica | nao sei | nao lembro | sem nome | só hífens
  if (/^(?:n\/a|nao se aplica|nao sei|nao lembro|sem nome|-+)$/.test(s)) return true;

  return false;
  }

  var rolePriority = { garcom:0, vendedor:1, atendente:2 };
  var best = null;
  var idxMap = {}; // header index to keep scanning order in case of tie

  // Map headers to preserve order indices
  var headers = Object.keys(record||{});
  for (var i=0;i<headers.length;i++) idxMap[headers[i]] = i;

  for (var h in record){
    if (!record.hasOwnProperty(h)) continue;
    var value = String(record[h]||'').trim();
    if (!value) continue;
    if (isBadValue(value)) continue;
    var hh = cleanHeader(h);

    var role = null;
    if (/(^|\b)garc(?:o|a)m(\b|$)/.test(hh)) role = 'garcom';
    else if (/(^|\b)vendedor(\b|$)/.test(hh)) role = 'vendedor';
    else if (/(^|\b)atendente(\b|$)/.test(hh)) role = 'atendente';
    if (!role) continue;

    var score = 0;
    if (/(^|\b)nome(\b|$)/.test(hh)) score += 2;
    if (/(^|\b)avaliad[oa](\b|$)/.test(hh)) score += 1;
    // headers mais curtos ("garçom") recebem score ligeiramente menor que "nome do garçom"
    var tie = {
      roleOrder: rolePriority[role],
      score: score,
      idx: idxMap[h]
    };
    var cand = { role: role, header: h, value: value, tie: tie };

    if (!best){
      best = cand;
    } else {
      // compara por papel, depois score, depois ordem de aparição
      if (cand.tie.roleOrder < best.tie.roleOrder) {
        best = cand;
      } else if (cand.tie.roleOrder === best.tie.roleOrder) {
        if (cand.tie.score > best.tie.score) {
          best = cand;
        } else if (cand.tie.score === best.tie.score && cand.tie.idx < best.tie.idx) {
          best = cand;
        }
      }
    }
  }
  return best ? String(best.value).trim() : '';
}
function ai_calcMedia_(metodo, pilares){
  const keys = pilares ? Object.keys(pilares) : [];
  if (!keys.length) return 0;
  const spec = ai_getMetodoSpec_(metodo);
  const order = spec.pillarOrder || [];
  if (order.length) {
    const vals = order.map(k => Number(pilares[k])).filter(v => !isNaN(v));
    if (vals.length) return vals.reduce((a,b)=>a+b,0)/vals.length;
  }
  const valsAll = keys.map(k => Number(pilares[k])).filter(v => !isNaN(v));
  if (!valsAll.length) return 0;
  return valsAll.reduce((a,b)=>a+b,0)/valsAll.length;
}
function ai_rankFromMedia_(m){ // 0..10
  if (m < 5) return 'Crítico';
  if (m < 7) return 'Regular';
  if (m < 8.5) return 'Bom';
  return 'Excelente';
}

function ai_extractNps_(record, npsHeader){
  // Função para normalizar e extrair valor numérico
  function extractNumericValue(val) {
    if (val == null) return null;
    const str = String(val).trim();
    if (str === '') return null;
    
    // Tenta extrair número diretamente primeiro
    let num = Number(str.replace(',', '.'));
    if (!isNaN(num) && num >= 0 && num <= 10) return num;
    
    // Se não conseguiu, tenta extrair número de formato "X (Classification)"
    // Ex: "7 (Passive)", "10 (Promoter)", "1 (Detractor)"
    const match = str.match(/^(\d{1,2})(?:\s*\([^)]*\))?/);
    if (match && match[1]) {
      num = Number(match[1]);
      if (!isNaN(num) && num >= 0 && num <= 10) return num;
    }
    
    // Tenta extrair número de qualquer posição na string (evita números negativos)
    const numberMatch = str.match(/(?:^|[^-])(\d{1,2})(?!\d)/);
    if (numberMatch) {
      num = Number(numberMatch[1]);
      if (!isNaN(num) && num >= 0 && num <= 10) return num;
    }
    
    return null;
  }

  // 1. Primeiro tenta o header específico configurado
  if (npsHeader) {
    const v = extractNumericValue(record[npsHeader]);
    if (v !== null) return v;
  }

  // 2. Procura por headers que contenham "nps"
  const npsKey = Object.keys(record||{}).find(h => String(h).toLowerCase().includes('nps'));
  if (npsKey) {
    const v = extractNumericValue(record[npsKey]);
    if (v !== null) return v;
  }

  // 3. Procura por variações comuns de perguntas NPS
  const npsPatterns = [
    /recomenda/i,
    /indicar/i, 
    /indicaria/i,
    /nota.*0.*10/i,
    /escala.*0.*10/i,
    /probabilidade.*recomendar/i,
    /chance.*recomendar/i,
    /net.promoter/i
  ];

  for (const header in record) {
    for (const pattern of npsPatterns) {
      if (pattern.test(header)) {
        const v = extractNumericValue(record[header]);
        if (v !== null) return v;
      }
    }
  }

  return null;
}

function ai_extractAspectosGeraisDetalhado_(record){
  const map = {higiene:0, simpatia:0, agilidade:0, educacao:0, atencao:0, qualidadePratos:0, variedadeBebidas:0, preco:0, ambiente:0};
  const cnt = {higiene:0, simpatia:0, agilidade:0, educacao:0, atencao:0, qualidadePratos:0, variedadeBebidas:0, preco:0, ambiente:0};
  const H = Object.keys(record||{});
  for (const h of H){
    const hl = String(h||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
    const v = record[h];
    const a = ai_answer01_multi_(v);
    if (!a.count) continue;
    const add = (k)=>{ map[k]+=a.v; cnt[k]++; };
    if (/\bhigien/.test(hl) || /\blimpez/.test(hl)) add('higiene');
    if (/\bsimpati/.test(hl) || /\bcordial/.test(hl)) add('simpatia');
    if (/\bagilidad/.test(hl) || /\bvelocidade/.test(hl)) add('agilidade');
    if (/\beduca[cç][aã]o/.test(hl) || /\brespeit/.test(hl)) add('educacao');
    if (/\batenc[aã]o/.test(hl) || /\bcuidad/.test(hl)) add('atencao');
    if (/\bqualidade\b/.test(hl) || /\bprato/.test(hl) || /\bcomida/.test(hl)) add('qualidadePratos');
    if (/\bbebida/.test(hl) || /\bvariedad/.test(hl)) add('variedadeBebidas');
    if (/\bpre[cç]o/.test(hl) || /\bcusto/.test(hl)) add('preco');
    if (/\bambient/.test(hl)) add('ambiente');
  }
  const to10 = (sum,c)=> c? +((sum/c)*10).toFixed(2) : null;
  return {
    higiene: to10(map.higiene,cnt.higiene),
    simpatia: to10(map.simpatia,cnt.simpatia),
    agilidade: to10(map.agilidade,cnt.agilidade),
    educacao: to10(map.educacao,cnt.educacao),
    atencao: to10(map.atencao,cnt.atencao),
    qualidadePratos: to10(map.qualidadePratos,cnt.qualidadePratos),
    variedadeBebidas: to10(map.variedadeBebidas,cnt.variedadeBebidas),
    preco: to10(map.preco,cnt.preco),
    ambiente: to10(map.ambiente,cnt.ambiente)
  };
}

function ai_computeDeterministico_(metodo, record, cfg){
  const calc = ai_extractPilaresFromRecord_(metodo, record) || {};
  const pilares = calc.pilares || {};
  const aspectosGerais = (typeof calc.aspectosGerais==='number') ? calc.aspectosGerais : null;
  const aspectosGeraisDetalhado = ai_extractAspectosGeraisDetalhado_(record);
  const nps = ai_extractNps_(record, (cfg && cfg.npsHeader) || '');
  const media = ai_calcMedia_(metodo, pilares) || 0;
  const ranking = ai_rankFromMedia_(media);
  const atributosGold = (calc.gold && typeof calc.gold === 'object') ? calc.gold : {};
  return { pilares, media, ranking, aspectosGerais, aspectosGeraisDetalhado, nps, atributosGold };
}

function ai_validateReport_(r){
  const missing = [];
  if (!r) return ['objeto_vazio'];
  // checagens mínimas para qualidade
  if (!Array.isArray(r.pontosFortes) || r.pontosFortes.length < 2) missing.push('pontosFortes(>=2)');
  if (!Array.isArray(r.pontosFracos) || r.pontosFracos.length < 2) missing.push('pontosFracos(>=2)');
  if (!Array.isArray(r.planoAcao)   || r.planoAcao.length   < 2) missing.push('planoAcao(>=2)');
  return missing;
}

/** ======= Renderiza PDF ======= */
function ai_renderPdf_(empresaId, metodo, meta, a, qa){
  try {
    const cfg = ai_getConfig_(empresaId);
    let folder = null;
    if (cfg.pdfFolderId) { try { folder = DriveApp.getFolderById(cfg.pdfFolderId); } catch(_) {} }
    if (!folder) {
      const root = DriveApp.getRootFolder();
      const p1 = getOrCreateFolder_(root, 'SuperSeller');
      const p2 = getOrCreateFolder_(p1, 'Relatorios AI');
      folder = getOrCreateFolder_(p2, String(empresaId||'SemEmpresa'));
    }
    const html = HtmlService.createHtmlOutput(ai_buildHtmlReport_(metodo, meta, a, qa)).setWidth(794).setHeight(1123);
    const blob = html.getAs('application/pdf').setName(`Relatorio_${meta.jobId||'semjob'}_${metodo}.pdf`);
    const file = folder.createFile(blob).setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    return { url: file.getUrl(), blob: file.getBlob() };
  } catch(e){ Logger.log('[AI] PDF fail: '+e); return null; }
  function getOrCreateFolder_(parent, name){ const it = parent.getFoldersByName(name); return it.hasNext()? it.next() : parent.createFolder(name); }
}
/** Identifica o código do pilar a partir do cabeçalho da pergunta conforme o método ativo. */
function ai_pillarFromHeader_(metodo, h){
  const spec = ai_getMetodoSpec_(metodo);
  const H0 = ai_normU_(h)
    .replace(/^CUSTOM (VARIABLE|VARIABLES):\s*/i,'')
    .replace(/^Q\d+\.\s*/, '');
  // quebremos em tokens alfanuméricos para garantir isolamento do código
  const tokens = H0.split(/[^A-Z0-9]+/).filter(Boolean);

  // códigos genéricos de aspectos (AG, Aspectos Gerais)
  if ((spec.aspectCodes || []).includes('AG')) {
    if (tokens.indexOf('AG') !== -1 || /ASPECTOS\s+GERAIS/.test(H0)) return 'AG';
  }

  if (spec.code === 'ASDAC') {
    const order = ['AB','SO','DI','AD','CO'];
    for (var i=0; i<order.length; i++){
      if (tokens.indexOf(order[i]) !== -1) return order[i];
    }
    return null;
  }

  if (spec.code === 'SERVIR+GOLD') {
    const first = tokens[0] || '';
    if (first === 'S') return 'S';
    if (first === 'E') return 'E';
    if (first === 'V') return 'V';
    if (first === 'I') return 'I';
    if (first === 'R') {
      if (/RETORNO|RELACIONAMENTO|RECORRENCIA|RECORR[EÊ]NCIA|AGRADECE|CONVID/.test(H0)) return 'R_REL';
      return 'R_REC';
    }
    if (spec.keywords) {
      for (var k=0; k<spec.keywords.length; k++){
        const pillar = spec.keywords[k];
        if (!pillar || !pillar.keywords) continue;
        for (var q=0; q<pillar.keywords.length; q++){
          const kw = pillar.keywords[q];
          if (kw && H0.indexOf(kw) !== -1) return pillar.code;
        }
      }
    }
    return null;
  }

  if (spec.keywords) {
    for (var k=0; k<spec.keywords.length; k++){
      const pillar = spec.keywords[k];
      if (!pillar || !pillar.keywords) continue;
      for (var q=0; q<pillar.keywords.length; q++){
        const kw = pillar.keywords[q];
        if (kw && H0.indexOf(kw) !== -1) return pillar.code;
      }
    }
  }
  return null;
}

function ai_detectGoldTags_(metodo, header){
  const spec = ai_getMetodoSpec_(metodo);
  if (!spec.goldAttributes) return [];
  const tags = [];
  const rawUp = String(header || '').toUpperCase();
  const H0 = ai_normU_(header);
  const kwMap = (spec.goldAttributes && spec.goldAttributes.keywords) || {};
  const order = (spec.goldAttributes && spec.goldAttributes.order) || [];

  order.forEach(code => {
    const list = kwMap[code] || [];
    const patternBase = code.replace(/[^A-Z0-9]/g, '');
    if (!patternBase) return;
    const explicit = rawUp.indexOf('(' + patternBase + ')') !== -1 ||
                     rawUp.indexOf('[' + patternBase + ']') !== -1 ||
                     rawUp.indexOf('{' + patternBase + '}') !== -1;
    const slash = rawUp.indexOf('/' + patternBase) !== -1 || rawUp.indexOf(patternBase + '/') !== -1;
    const normalizedHit = list.some(kw => kw && H0.indexOf(String(kw||'').toUpperCase()) !== -1);
    if (explicit || slash || normalizedHit) tags.push(code);
  });
  return tags;
}

function ai_groupHeadersByGold_(metodo, record){
  const spec = ai_getMetodoSpec_(metodo);
  if (!spec.goldAttributes) return {};
  const out = {};
  (spec.goldAttributes.order || []).forEach(code => { out[code] = []; });
  Object.keys(record||{}).forEach(header=>{
    const tags = ai_detectGoldTags_(metodo, header);
    tags.forEach(code=>{
      if (!out[code]) out[code] = [];
      out[code].push(header);
    });
  });
  return out;
}

function ai_formatHeaderLabel_(metodo, header){
  const spec = ai_getMetodoSpec_(metodo);
  const pillarCode = ai_pillarFromHeader_(metodo, header) || '';
  const pillarLabel = pillarCode && spec.pillarLabels ? (spec.pillarLabels[pillarCode] || pillarCode) : pillarCode;
  const goldTags = ai_detectGoldTags_(metodo, header);
  const goldLabels = (spec.goldAttributes && spec.goldAttributes.labels) || {};
  const goldPart = goldTags.map(code => `${code} – ${(goldLabels[code] || code)}`).join(', ');
  const parts = [];
  if (pillarCode) {
    parts.push(`${pillarCode}${pillarLabel && pillarLabel !== pillarCode ? ` – ${pillarLabel}` : ''}`);
  }
  if (goldPart) {
    parts.push(`GOLD: ${goldPart}`);
  }
  const base = parts.length ? parts.join(' | ') : '';
  return base ? `${base} → ${header}` : header;
}
/** ======= Helper de logo (data URL) ======= */
function _getLogoDataUrl_() {
  const tryUrls = [
    LOGO_URL,
    'https://storage.googleapis.com/supersellerco-f5a61.appspot.com/Imagens/Superseller.png'
  ];
  for (var i = 0; i < tryUrls.length; i++) {
    try {
      var res = UrlFetchApp.fetch(tryUrls[i], { muteHttpExceptions: true, followRedirects: true });
      if (res.getResponseCode() === 200) {
        var blob = res.getBlob();
        var ctHeader = (res.getHeaders() && (res.getHeaders()['Content-Type'] || res.getHeaders()['content-type'])) || '';
        var ctBlob = (blob && blob.getContentType && blob.getContentType()) || '';
        var ct = String(ctBlob || ctHeader || '').toLowerCase();
        // normaliza e remove parâmetros (charset, boundary, etc.)
        var ctNorm = ct.split(';')[0].trim();
        // somente aceita quando for realmente imagem
        if (ctNorm && ctNorm.indexOf('image/') === 0) {
          var b64 = Utilities.base64Encode(blob.getBytes());
          return 'data:' + ctNorm + ';base64,' + b64;
        }
        // caso não seja imagem, tenta próximo fallback
      }
    } catch (_) {}
  }
  return '';
}

/** ======= HTML do PDF ======= */
function ai_buildHtmlReport_(metodo, meta, a, qa){
  const spec = ai_getMetodoSpec_(metodo);
  if (spec.code === 'SERVIR+GOLD') {
    return ai_buildHtmlReport_SERVIR_(spec, metodo, meta, a, qa);
  }
  return ai_buildHtmlReport_ASDAC_(spec, metodo, meta, a, qa);
}

function ai_buildNarrativeFeedback_(metodo, record){
  const spec = ai_getMetodoSpec_(metodo);
  const pillarOrder = spec.pillarOrder || [];
  const pillarStats = {};
  pillarOrder.forEach(function(code){
    pillarStats[code] = {
      code: code,
      label: (spec.pillarLabels && spec.pillarLabels[code]) || code,
      pos: 0,
      neg: 0,
      total: 0
    };
  });
  const aspectLabel = (spec.aspectLabels && spec.aspectLabels.AG) || 'Aspectos Gerais';
  const aspectsStats = { label: aspectLabel, pos: 0, neg: 0, total: 0 };
  const POS_THRESHOLD = 0.7;
  const NEG_THRESHOLD = 0.45;
  let totalPos = 0;
  let totalNeg = 0;
  let descriptionText = '';

  function registerSignal(target, value){
    const info = ai_answer01_multi_(value);
    if (!info.count) return;
    target.total += 1;
    if (info.v >= POS_THRESHOLD) {
      target.pos += 1;
      totalPos += 1;
    } else if (info.v <= NEG_THRESHOLD) {
      target.neg += 1;
      totalNeg += 1;
    }
  }

  Object.keys(record || {}).forEach(function(header){
    const value = record[header];
    const headerNorm = ai_norm_(header);
    if (!descriptionText && /descricao.*atendimento/.test(headerNorm)) {
      descriptionText = ai_servirAnswerText_(value);
    }
    const code = ai_pillarFromHeader_(metodo, header);
    if (code === 'AG') {
      registerSignal(aspectsStats, value);
      return;
    }
    if (pillarStats.hasOwnProperty(code)) {
      registerSignal(pillarStats[code], value);
    }
  });

  const pillarStatsList = (pillarOrder.length ? pillarOrder : Object.keys(pillarStats)).map(function(code){
    return pillarStats[code];
  }).filter(function(stat){ return !!stat; });

  function formatListPt_(items){
    if (!items.length) return '';
    if (items.length === 1) return items[0];
    if (items.length === 2) return items[0] + ' e ' + items[1];
    return items.slice(0, -1).join(', ') + ' e ' + items[items.length - 1];
  }

  function analyzeDescriptionSentiment_(text){
    const clean = ai_norm_(text);
    if (!clean) return 'neutral';
    const positives = ['excelent','otim','positiv','bom','boa','agrad','agil','rap','gentil','cordial','educad','acolh','satisfeit','eficient','organ','cuid'];
    const negatives = ['ruim','pessim','demor','lento','falh','proble','desagrad','falt','desorgan','irrit','frustr','confus','precari','gross','rude','insatisf'];
    function score(list){
      return list.reduce(function(acc, token){
        return acc + (clean.indexOf(token) !== -1 ? 1 : 0);
      }, 0);
    }
    const posScore = score(positives);
    const negScore = score(negatives);
    if (posScore === 0 && negScore === 0) return 'neutral';
    if (posScore >= negScore * 1.2 || (posScore > 0 && negScore === 0)) return 'positive';
    if (negScore >= posScore * 1.2 || (negScore > 0 && posScore === 0)) return 'negative';
    return 'neutral';
  }

  const descSentiment = analyzeDescriptionSentiment_(descriptionText);

  const positiveParts = [];
  const positivePillars = pillarStatsList.filter(function(stat){
    return stat.pos > 0 && stat.pos >= stat.neg;
  });
  if (positivePillars.length) {
    const labels = positivePillars.map(function(stat){ return stat.label; });
    positiveParts.push('Os pilares ' + formatListPt_(labels) + ' mostraram aderência consistente, com respostas predominantemente positivas durante a visita.');
  }
  if (aspectsStats.pos > aspectsStats.neg) {
    positiveParts.push(aspectsStats.label + ' reforçaram a percepção de qualidade apontada pelo cliente oculto.');
  }
  if (descSentiment === 'positive') {
    positiveParts.push('O relato do atendimento descreve uma experiência fluida, fortalecendo a satisfação geral.');
  }
  let satisfacoes = '';
  if (positiveParts.length) {
    satisfacoes = positiveParts.join(' ');
  } else if (totalPos > 0) {
    satisfacoes = 'As respostas positivas apareceram de forma pontual, indicando comportamentos adequados sem formar um padrão dominante.';
  } else {
    satisfacoes = 'Não foram registradas evidências positivas relevantes nas perguntas analisadas.';
  }

  const negativeParts = [];
  const negativePillars = pillarStatsList.filter(function(stat){
    return stat.neg > 0 && stat.neg >= stat.pos;
  });
  if (negativePillars.length) {
    const labelsNeg = negativePillars.map(function(stat){ return stat.label; });
    negativeParts.push('Foram identificadas lacunas nos pilares ' + formatListPt_(labelsNeg) + ', sinalizando oportunidades claras de correção nos comportamentos observados.');
  }
  if (aspectsStats.neg > aspectsStats.pos) {
    negativeParts.push(aspectsStats.label + ' indicaram insatisfação do cliente, com percepções abaixo do esperado para a experiência.');
  }
  if (descSentiment === 'negative') {
    negativeParts.push('O relato do atendimento cita dificuldades específicas que comprometeram a percepção final do cliente.');
  }
  let frustracoes = '';
  if (negativeParts.length) {
    frustracoes = negativeParts.join(' ');
  } else if (totalNeg > 0) {
    frustracoes = 'As respostas negativas surgiram de forma isolada, sem apontar um padrão consistente de frustração.';
  } else {
    frustracoes = 'Não foram identificadas frustrações relevantes nas perguntas analisadas.';
  }

  return { satisfacoes: satisfacoes, frustracoes: frustracoes };
}

function ai_asdacEnsureEnrichment_(metodo, analysis, record){
  const out = (analysis && typeof analysis === 'object') ? analysis : {};
  const rec = (record && typeof record === 'object') ? record : {};

  function normalizeList(val){
    if (!val && val !== 0) return [];
    const acc = [];
    const pushText = (raw) => {
      const text = String(raw || '').trim();
      if (text && acc.indexOf(text) === -1) acc.push(text);
    };
    if (Array.isArray(val)) {
      val.forEach(item => {
        if (item && typeof item === 'object' && !Array.isArray(item)) {
          if (item.acao) pushText(item.acao);
          else if (item.text) pushText(item.text);
          else if (item.description) pushText(item.description);
          else if (item.value) pushText(item.value);
        } else {
          pushText(item);
        }
      });
      return acc;
    }
    if (val && typeof val === 'object') {
      Object.keys(val).forEach(key => pushText(val[key]));
      return acc;
    }
    pushText(val);
    return acc;
  }

  function pushUnique(list, value){
    const text = String(value || '').trim();
    if (!text) return;
    if (list.indexOf(text) === -1) list.push(text);
  }

  out.recomendacoesPraticas = (out.recomendacoesPraticas && typeof out.recomendacoesPraticas === 'object')
    ? out.recomendacoesPraticas
    : {};
  const recs = out.recomendacoesPraticas;
  recs.horizonte = (recs.horizonte && typeof recs.horizonte === 'object') ? recs.horizonte : {};
  const horizon = recs.horizonte;
  const buckets = {
    dias7: normalizeList(horizon.dias7),
    dias30: normalizeList(horizon.dias30),
    dias90: normalizeList(horizon.dias90)
  };

  if (Array.isArray(out.planoAcao)) {
    out.planoAcao.forEach(item => {
      const rawText = item && typeof item === 'object' ? (item.acao || item.text || item.description || '') : item;
      const acao = String(rawText || '').trim();
      if (!acao) return;
      const prazoRaw = item && typeof item === 'object' ? item.prazoDias : null;
      const prazo = (prazoRaw === '' || prazoRaw == null) ? NaN : Number(prazoRaw);
      if (!isNaN(prazo)) {
        if (prazo <= 7) pushUnique(buckets.dias7, acao);
        else if (prazo <= 30) pushUnique(buckets.dias30, acao);
        else pushUnique(buckets.dias90, acao);
      } else {
        pushUnique(buckets.dias30, acao);
      }
    });
  }

  if (!buckets.dias7.length || !buckets.dias30.length || !buckets.dias90.length) {
    const detalhada = (out.analiseDetalhada && typeof out.analiseDetalhada === 'object') ? out.analiseDetalhada : {};
    Object.keys(detalhada).forEach(key => {
      if (buckets.dias7.length && buckets.dias30.length && buckets.dias90.length) return;
      const etapa = detalhada[key];
      if (!etapa || typeof etapa !== 'object') return;
      const melhoria = String(etapa.melhoria || '').trim();
      if (!melhoria) return;
      if (!buckets.dias7.length) pushUnique(buckets.dias7, melhoria);
      else if (!buckets.dias30.length) pushUnique(buckets.dias30, melhoria);
      else if (!buckets.dias90.length) pushUnique(buckets.dias90, melhoria);
    });
  }

  if (!buckets.dias7.length || !buckets.dias30.length || !buckets.dias90.length) {
    const melhorias = normalizeList(out.pontosFracos).concat(normalizeList(out.planoAcao));
    melhorias.forEach(text => {
      if (!buckets.dias7.length) pushUnique(buckets.dias7, text);
      else if (!buckets.dias30.length) pushUnique(buckets.dias30, text);
      else if (!buckets.dias90.length) pushUnique(buckets.dias90, text);
    });
  }

  horizon.dias7 = buckets.dias7.slice(0, 4);
  horizon.dias30 = buckets.dias30.slice(0, 4);
  horizon.dias90 = buckets.dias90.slice(0, 4);
  recs.horizonte = horizon;
  out.recomendacoesPraticas = recs;

  out.aspectosGeraisDetalhado = (out.aspectosGeraisDetalhado && typeof out.aspectosGeraisDetalhado === 'object')
    ? out.aspectosGeraisDetalhado
    : {};
  const ag = out.aspectosGeraisDetalhado;
  const narrativas = ai_buildNarrativeFeedback_(metodo, rec);
  ag.satisfacoes = narrativas.satisfacoes ? [narrativas.satisfacoes] : [];
  ag.frustracoes = narrativas.frustracoes ? [narrativas.frustracoes] : [];
  out.aspectosGeraisDetalhado = ag;

  return out;
}


function ai_buildHtmlReport_ASDAC_(spec, metodo, meta, a, qa){
  const record = (qa && qa.record) ? qa.record : {};
  a = ai_asdacEnsureEnrichment_(metodo, a, record);
  const pilares = a.pilares || {};
  const defs = spec.pillarLabels || {};
  const methodDisplay = spec.display || String(metodo || "").toUpperCase();

  function escapeHtml_(s){
    const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
    return String(s || "").replace(/[&<>"']/g, function(ch){ return map[ch]; });
  }
  function toArray_(val){
    if (val == null) return [];
    if (Array.isArray(val)) return val.slice();
    if (typeof val === "object") return Object.keys(val).map(k => val[k]);
    return [val];
  }
  function toStringList_(val){
    return toArray_(val).map(function(item){
      if (item == null) return '';
      if (Array.isArray(item)) return item.map(String).join(' ');
      if (typeof item === 'object') {
        if (typeof item.text === 'string') return item.text;
        if (typeof item.acao === 'string') return item.acao;
        if (typeof item.description === 'string') return item.description;
      }
      return String(item);
    }).map(function(s){ return s.trim(); }).filter(Boolean);
  }
  function sanitizeFeedback_(text){
    let out = String(text || '').trim();
    if (!out) return '';
    out = out.replace(/^(Falhou|Não atendeu ao esperado|Atendeu ao esperado)\s+em:\s*/i, '');
    const arrowIdx = out.indexOf('→');
    if (arrowIdx !== -1) out = out.slice(arrowIdx + 1).trim();
    out = out.replace(/^Q\d+[.\-\s]*/i, '');
    out = out.replace(/^[A-Z]{1,3}\.\d+\)\s*/,'');
    out = out.replace(/^[A-Z]{1,4}\s*[–-]\s*/,'');
    out = out.replace(/^[•\-–]+\s*/, '');
    out = out.replace(/\s*\([^)]*\)\s*$/, '').trim();
    out = out.replace(/\s*[?!.…]+$/, '').trim();
    if (!/\bdeve\b/i.test(out)) {
      const verbReplacements = [
        { pattern: /\b(perguntou|perguntar)\b/i, replacement: 'deve perguntar' },
        { pattern: /\b(ofereceu|oferecer)\b/i, replacement: 'deve oferecer' },
        { pattern: /\b(apresentou|apresentar)\b/i, replacement: 'deve apresentar' },
        { pattern: /\b(convidou|convidar)\b/i, replacement: 'deve convidar' },
        { pattern: /\b(agradeceu|agradecer)\b/i, replacement: 'deve agradecer' },
        { pattern: /\b(validou|validar)\b/i, replacement: 'deve validar' },
        { pattern: /\b(registrou|registrar)\b/i, replacement: 'deve registrar' },
        { pattern: /\b(explicou|explicar)\b/i, replacement: 'deve explicar' },
        { pattern: /\b(reforçou|reforcar|reforçar)\b/i, replacement: 'deve reforçar' }
      ];
      verbReplacements.forEach(function(rule){
        out = out.replace(rule.pattern, function(match){
          const rep = rule.replacement;
          if (/^[A-ZÁÉÍÓÚÂÊÔÃÕÀÇ]/.test(match)) {
            return rep.charAt(0).toUpperCase() + rep.slice(1);
          }
          return rep;
        });
      });
    }
    if (!out) return '';
    out = out.charAt(0).toUpperCase() + out.slice(1);
    if (!/[.!?]$/.test(out)) out += '.';
    return out;
  }
  function listHtml(items){
    const arr = toStringList_(items).map(escapeHtml_);
    if (!arr.length) return "<li>—</li>";
    return arr.map(function(x){ return `<li>${x}</li>`; }).join("");
  }
  function feedbackListHtml(items){
    const arr = toStringList_(items).map(sanitizeFeedback_).filter(Boolean);
    if (!arr.length) return "<li>—</li>";
    return arr.map(function(x){ return `<li>${escapeHtml_(x)}</li>`; }).join("");
  }
  function formatPilarLabel_(code){
    const label = defs[code] || code;
    return `${code}${label && label !== code ? ` – ${label}` : ''}`;
  }
  function formatDateBr_(iso){
    try{
      let d = iso ? new Date(String(iso).trim()) : null;
      if (iso && /^\d{4}-\d{2}-\d{2}$/.test(String(iso))) d = new Date(String(iso) + "T00:00:00");
      const dt = (d && !isNaN(d)) ? d : new Date();
      const dias  = ["domingo","segunda-feira","terça-feira","quarta-feira","quinta-feira","sexta-feira","sábado"];
      const meses = ["janeiro","fevereiro","março","abril","maio","junho","julho","agosto","setembro","outubro","novembro","dezembro"];
      const dd = String(dt.getDate()).padStart(2,"0");
      return `${dias[dt.getDay()]}, ${dd} de ${meses[dt.getMonth()]} de ${dt.getFullYear()}`;
    }catch(_){ return String(iso||""); }
  }
  function toNumber(val, fallback){
    if (val === null || typeof val === "undefined" || val === "") return fallback;
    const num = Number(val);
    return isNaN(num) ? fallback : num;
  }
  function pctFrom10(val){
    if (!Number.isFinite(val)) return 0;
    return Math.max(0, Math.min(100, Math.round(val * 10)));
  }
  function formatScore(val, digits){
    if (!Number.isFinite(val)) return "—";
    return val.toFixed(digits);
  }
  function pillarStatus(note){
    if (!Number.isFinite(note)) return { cls:"warn", label:"Sem dados" };
    if (note >= 8.5) return { cls:"ok", label:"Excelente" };
    if (note >= 7) return { cls:"warn", label:"Atenção" };
    return { cls:"bad", label:"Crítico" };
  }

  const dataBR = formatDateBr_(meta.dataISO);
  const order = spec.pillarOrder || Object.keys(pilares||{});
  const logoSrc = _getLogoDataUrl_() || LOGO_URL;

  const mediaVal = toNumber(a.media, null);
  const aspectosVal = toNumber(a.aspectosGerais, null);
  const npsVal = toNumber(a.nps, null);
  const mediaCalc = formatScore(mediaVal, 1);
  const aspectos = formatScore(aspectosVal, 1);
  const npsText = formatScore(npsVal, 0);
  const npsInfo = pillarStatus(npsVal);
  npsInfo.label = !Number.isFinite(npsVal) ? 'Sem nota' : (npsVal >= 9 ? 'Promotor' : (npsVal >= 7 ? 'Neutro' : 'Detrator'));
  npsInfo.cls = !Number.isFinite(npsVal) ? 'warn' : (npsVal >= 9 ? 'ok' : (npsVal >= 7 ? 'warn' : 'bad'));

  const se = (a.sumarioExecutivo && typeof a.sumarioExecutivo === 'object') ? a.sumarioExecutivo : {};
  const ad = (a.analiseDetalhada && typeof a.analiseDetalhada === 'object') ? a.analiseDetalhada : {};
  const ag = (a.aspectosGeraisDetalhado && typeof a.aspectosGeraisDetalhado === 'object') ? a.aspectosGeraisDetalhado : {};
  const pontosFortesList = toStringList_(a.pontosFortes);
  const pontosFracosList = toStringList_(a.pontosFracos);

  const principaisFortes = toStringList_(se.principaisFortes);
  const principaisFracos = toStringList_(se.principaisFracos);

  const keyTakeaways = toStringList_(se.pontosChave);
  if (se.insightCentral) keyTakeaways.unshift(String(se.insightCentral));
  if (se.classificacaoRanking) keyTakeaways.push(`Classificação: ${se.classificacaoRanking}`);
  if (!keyTakeaways.length && pontosFortesList.length) keyTakeaways.push(pontosFortesList[0]);
  if (!keyTakeaways.length && pontosFracosList.length) keyTakeaways.push(pontosFracosList[0]);
  const keyTakeawaysHtml = listHtml(keyTakeaways);
  const fortesResumoHtml = listHtml(principaisFortes.length ? principaisFortes : pontosFortesList);
  const fracosResumoHtml = listHtml(principaisFracos.length ? principaisFracos : pontosFracosList);

  const analiticaRows = order.map(code => {
    const nota = Number(pilares[code]);
    const pct = Number.isFinite(nota) ? pctFrom10(nota) : null;
    const badge = pillarStatus(nota);
    return `<tr>
      <td>${escapeHtml_(formatPilarLabel_(code))}</td>
      <td>${formatScore(nota, 1)}</td>
      <td>${pct !== null ? pct + '%' : '—'}</td>
      <td><span class="status ${badge.cls}">${badge.label}</span></td>
    </tr>`;
  }).join('');

  function renderListBlock(items){
    const arr = toStringList_(items);
    if (!arr.length) return '<p class="muted">Sem recomendações registradas.</p>';
    return `<ul class="plain-list">${arr.map(function(s){ return `<li>${escapeHtml_(s)}</li>`; }).join('')}</ul>`;
  }
  function renderPlanRow(label, items){
    const arr = toStringList_(items);
    if (!arr.length) return `<tr><td>${escapeHtml_(label)}</td><td>—</td></tr>`;
    const lis = arr.map(function(s){ return `<li>${escapeHtml_(s)}</li>`; }).join('');
    return `<tr><td>${escapeHtml_(label)}</td><td><ul class="plain-list">${lis}</ul></td></tr>`;
  }
  function feedbackSummaryText(items, fallback){
    const arr = toStringList_(items).map(sanitizeFeedback_).filter(Boolean);
    if (!arr.length) return fallback;
    return arr.join(' ');
  }

  const aspectosDetalhe = (function(){
    const agObj = ag || {};
    const rows = [
      ['Higiene','higiene'],['Simpatia','simpatia'],['Agilidade','agilidade'],['Educação','educacao'],
      ['Atenção','atencao'],['Qualidade dos pratos','qualidadePratos'],['Variedade de bebidas','variedadeBebidas'],
      ['Preço','preco'],['Ambiente','ambiente']
    ].map(function([label,key]){
      const raw = agObj && agObj[key] != null && agObj[key] !== '' ? Number(agObj[key]).toFixed(1) : '—';
      return `<tr><td>${escapeHtml_(label)}</td><td>${raw}</td></tr>`;
    }).join('');
    const satisResumo = feedbackSummaryText(agObj.satisfacoes, 'Sem destaques positivos registrados.');
    const frusResumo = feedbackSummaryText(agObj.frustracoes, 'Sem pontos de melhoria registrados.');
    return { rows, satisResumo, frusResumo };
  })();

  const rpRaw = (a.recomendacoesPraticas && typeof a.recomendacoesPraticas === 'object') ? a.recomendacoesPraticas : {};
  const recsVendedorBlock = renderListBlock(rpRaw.garcom);
  const recsGestorBlock = renderListBlock(rpRaw.gestor);
  const horizon = (rpRaw.horizonte && typeof rpRaw.horizonte === 'object') ? rpRaw.horizonte : {};
  const planTableHtml = `
<table class="plan-table">
  <thead><tr><th>Prazo</th><th>Ações sugeridas</th></tr></thead>
  <tbody>
    ${renderPlanRow('Até 7 dias', horizon.dias7)}
    ${renderPlanRow('Até 30 dias', horizon.dias30)}
    ${renderPlanRow('Até 90 dias', horizon.dias90)}
  </tbody>
</table>`;

  const insightsList = toStringList_(a.insightsEstrategicos);
  const insightsHtml = listHtml(insightsList);
  const satisfacoesResumo = aspectosDetalhe.satisResumo;
  const frustracoesResumo = aspectosDetalhe.frusResumo;

  const qaHtml = (function(){
    if (!qa || !qa.headers || !qa.record) return '<tr><td colspan="2">—</td></tr>';
    const ignore = ['respondent id','collector id','collector name','language','start date','end date','time spent','ip address','email address','first name','last name','voucher','job id','job_id','user email','user_email','empresaid','company id','companyid'];
    const clean = s => String(s||'')
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/^custom (variable|variables):\s*/i,'')
      .replace(/[_:]+/g,' ')
      .trim()
      .toLowerCase();
    const rows = [];
    for (let i=0;i<qa.headers.length;i++){
      const rawH = qa.headers[i];
      const rawV = qa.record[rawH];
      const key = clean(rawH);
      const val = String(rawV||'').trim();
      if (!val) continue;
      if (ignore.some(token => key.includes(token))) continue;
      rows.push(`<tr><td><b>${escapeHtml_(rawH)}</b></td><td>${escapeHtml_(val)}</td></tr>`);
    }
    return rows.length ? rows.join('') : '<tr><td colspan="2">—</td></tr>';
  })();

  return `
<!DOCTYPE html><html><head><meta charset="utf-8"/>
<style>
  :root{ --bg:#F7F9FB; --panel:#FFFFFF; --ink:#0B1F22; --muted:#5B6B73; --line:#E6ECEF; --ok:#16A34A; --warn:#F59E0B; --bad:#EF4444; --radius:14px; }
  *{box-sizing:border-box;}
  body{ font-family:Inter,Arial,sans-serif; color:var(--ink); background:var(--bg); margin:0; padding:34px; -webkit-print-color-adjust:exact; print-color-adjust:exact; }
  .page{ max-width:960px; margin:0 auto; }
  h1{ font-size:26px; margin:0; line-height:1.2; }
  h2{ font-size:18px; margin:22px 0 10px; color:#0F2E34; }
  .muted{ color:var(--muted); }
  .badge{ display:inline-flex; align-items:center; gap:8px; padding:7px 12px; border-radius:999px; font-size:12px; background:#E0F2FE; color:#0F2E34; font-weight:600; }
  .header{ display:flex; align-items:center; justify-content:space-between; gap:18px; }
  .header-info{ display:flex; flex-direction:column; gap:6px; }
  .meta{ color:var(--muted); font-size:13px; }
  .logo img{ height:40px; display:block; }
  .kpis{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px; margin-top:20px; }
  .kpi{ background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:14px; }
  .kpi .label{ color:var(--muted); font-size:12px; margin-bottom:6px; text-transform:uppercase; letter-spacing:.05em; }
  .kpi .value{ font-size:22px; font-weight:700; }
  .progress{ height:10px; background:#EFF4F7; border-radius:999px; overflow:hidden; margin-top:10px; }
  .progress span{ display:block; height:100%; background:linear-gradient(90deg,#1D4ED8,#38BDF8); }
  .status{ font-size:12px; font-weight:600; padding:4px 10px; border-radius:999px; display:inline-block; }
  .status.ok{ background:rgba(22,163,74,.12); color:var(--ok); }
  .status.warn{ background:rgba(245,158,11,.12); color:var(--warn); }
  .status.bad{ background:rgba(239,68,68,.12); color:var(--bad); }
  .card{ background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); margin-top:24px; }
  .card .hd{ padding:14px 16px; border-bottom:1px solid var(--line); background:#F1F5F9; font-weight:600; }
  .card .bd{ padding:16px 20px; }
  .stack-cards{ display:flex; flex-direction:column; gap:12px; }
  .stack-cards .subcard{ background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:14px; }
  .stack-cards .subcard-title{ font-weight:600; color:#0F2E34; margin-bottom:6px; }
  .grid{ display:grid; gap:16px; }
  .grid.cols-3{ grid-template-columns:repeat(3,minmax(0,1fr)); }
  table{ width:100%; border-collapse:collapse; background:var(--panel); border-radius:12px; overflow:hidden; font-size:14px; }
  thead th{ background:#F1F5F9; font-weight:600; padding:10px 12px; border-bottom:1px solid var(--line); text-align:left; }
  tbody td{ padding:10px 12px; border-bottom:1px solid var(--line); vertical-align:top; }
  .plan-table{ width:100%; border-collapse:collapse; margin-top:10px; border-radius:12px; overflow:hidden; }
  .plan-table th, .plan-table td{ border:1px solid var(--line); padding:10px 12px; text-align:left; vertical-align:top; background:#FFFFFF; }
  .plan-table th{ background:#F1F5F9; font-weight:600; }
  .plain-list{ margin:0; padding-left:20px; }
  .plain-list li{ margin-bottom:4px; }
  .section{ margin-top:28px; }
  .summary-card{ margin-top:16px; }
  .summary-card .bd{ padding:16px 20px; }
  .summary-card .bd p{ margin:0; white-space:pre-line; }
  .page-break{ page-break-before:always; }
  .commentary{ background:#F5F6F7; border-radius:16px; padding:18px 22px; margin-top:24px; }
  .commentary table{ width:100%; border-collapse:collapse; margin-top:12px; }
  .commentary td{ padding:8px 10px; border:1px solid #E5E7EB; background:#fff; }
  .footer{ margin-top:24px; color:var(--muted); font-size:12px; display:flex; justify-content:space-between; }
  @page{ size:A4; margin:18mm 15mm; }
  @media print{ body{ background:#fff; padding:0; } .page{ max-width:none; } .card{ border-color:#D9E2EC; } }
</style></head>
<body>
  <div class="page">
    <div class="header">
      <div class="header-info">
        <span class="badge">${escapeHtml_(methodDisplay)}</span>
        <h1>${escapeHtml_(meta.estabelecimento||'Avaliação')}</h1>
        <div class="meta">Visita em ${escapeHtml_(dataBR)} • Job ${escapeHtml_(meta.jobId||'—')} • Voucher ${escapeHtml_(meta.voucher||'—')}</div>
      </div>
      <div class="logo"><img src="${logoSrc}" alt="SuperSeller" /></div>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="label">Média ASDAC</div>
        <div class="value">${mediaCalc}</div>
        <div class="progress"><span style="width:${pctFrom10(mediaVal)}%"></span></div>
      </div>
      <div class="kpi">
        <div class="label">Aspectos gerais</div>
        <div class="value">${aspectos}</div>
        <div class="progress"><span style="width:${pctFrom10(aspectosVal)}%"></span></div>
      </div>
      <div class="kpi">
        <div class="label">NPS</div>
        <div class="value">${npsText}</div>
        <div class="status ${npsInfo.cls}" style="margin-top:10px;">${npsInfo.label}</div>
      </div>
    </div>

    <div class="card">
      <div class="hd">Sumário executivo</div>
      <div class="bd">
        <div class="grid cols-3">
          <div><h2>Pontos-chave</h2><ul>${keyTakeawaysHtml}</ul></div>
          <div><h2>Forças</h2><ul>${fortesResumoHtml}</ul></div>
          <div><h2>Fragilidades</h2><ul>${fracosResumoHtml}</ul></div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>ASDAC – notas, acertos e oportunidades</h2>
      <div class="card" style="margin-top:10px;">
        <div class="bd" style="padding:0;">
          <table>
            <thead><tr><th>Etapa</th><th>Nota</th><th>Acerto</th><th>Status</th></tr></thead>
            <tbody>${analiticaRows}</tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Recomendações práticas</h2>
      <div class="card">
        <div class="bd">
          <div class="stack-cards">
            <div class="subcard">
              <div class="subcard-title">Para o Vendedor</div>
              ${recsVendedorBlock}
            </div>
            <div class="subcard">
              <div class="subcard-title">Para o Gestor</div>
              ${recsGestorBlock}
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Plano de ação</h2>
      <div class="card">
        <div class="bd">
          ${planTableHtml}
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Aspectos gerais</h2>
      <div class="card">
        <div class="hd">Notas detalhadas</div>
        <div class="bd" style="padding:0;">
          <table><tbody>${aspectosDetalhe.rows}</tbody></table>
        </div>
      </div>
      <div class="card summary-card">
        <div class="hd">Satisfações</div>
        <div class="bd"><p>${escapeHtml_(satisfacoesResumo)}</p></div>
      </div>
      <div class="card summary-card">
        <div class="hd">Frustrações</div>
        <div class="bd"><p>${escapeHtml_(frustracoesResumo)}</p></div>
      </div>
    </div>

    ${insightsList.length ? `<div class="section"><div class="card" style="margin-top:0;"><div class="hd">Insights estratégicos</div><div class="bd"><ul>${insightsHtml}</ul></div></div></div>` : ''}

    <div class="footer">
      <div>Relatório gerado automaticamente pela IA SuperSeller — ${escapeHtml_(methodDisplay)}</div>
      <div>${escapeHtml_(meta.dataISO || meta.data || '')}</div>
    </div>
  </div>

  <div class="page page-break">
    <h2>Respostas do avaliador</h2>
    <div class="commentary">
      ${a.sinteseComentarios ? `<p><b>Síntese interpretativa:</b> ${escapeHtml_(a.sinteseComentarios)}</p>` : ''}
      <table>${qaHtml}</table>
    </div>
  </div>
</body></html>`;
}
function ai_servirEnsureEnrichment_(metodo, analysis, record){
  const spec = ai_getMetodoSpec_(metodo);
  const out = (analysis && typeof analysis === 'object') ? analysis : {};
  const stageOrder = spec.pillarOrder || [];
  const rec = record && typeof record === 'object' ? record : {};

  function asCleanArray(arr){
    return Array.isArray(arr) ? arr.map(v => String(v||'').trim()).filter(Boolean) : [];
  }

  out.analiseDetalhada = out.analiseDetalhada && typeof out.analiseDetalhada === 'object' ? out.analiseDetalhada : {};
  stageOrder.forEach(code => {
    const current = out.analiseDetalhada[code] && typeof out.analiseDetalhada[code] === 'object' ? out.analiseDetalhada[code] : {};
    const fallback = ai_servirStageFallback_(metodo, code, rec);

    const behaviors = asCleanArray(current.comportamentos);
    current.comportamentos = behaviors.length ? behaviors : fallback.comportamentos;

    const impacto = String(current.impacto || '').trim();
    current.impacto = impacto || fallback.impacto;

    const melhoria = String(current.melhoria || '').trim();
    current.melhoria = melhoria || fallback.melhoria;

    out.analiseDetalhada[code] = current;
  });

  out.recomendacoesPraticas = out.recomendacoesPraticas && typeof out.recomendacoesPraticas === 'object' ? out.recomendacoesPraticas : {};
  const recs = out.recomendacoesPraticas;
  recs.garcom = asCleanArray(recs.garcom);
  recs.gestor = asCleanArray(recs.gestor);

  recs.horizonte = recs.horizonte && typeof recs.horizonte === 'object' ? recs.horizonte : {};
  const horizon = recs.horizonte;
  horizon.dias7 = asCleanArray(horizon.dias7);
  horizon.dias30 = asCleanArray(horizon.dias30);
  horizon.dias90 = asCleanArray(horizon.dias90);

  if ((!horizon.dias7.length || !horizon.dias30.length || !horizon.dias90.length) && Array.isArray(out.planoAcao)) {
    const buckets = {
      dias7: horizon.dias7.slice(),
      dias30: horizon.dias30.slice(),
      dias90: horizon.dias90.slice()
    };
    out.planoAcao.forEach(item => {
      const acao = item && typeof item === 'object' ? String(item.acao || '').trim() : String(item||'').trim();
      if (!acao) return;
      const rawPrazo = item && typeof item === 'object' ? item.prazoDias : null;
      const prazo = rawPrazo === '' || rawPrazo == null ? NaN : Number(rawPrazo);
      if (!isNaN(prazo)) {
        if (prazo <= 7 && buckets.dias7.indexOf(acao) === -1) buckets.dias7.push(acao);
        else if (prazo <= 30 && buckets.dias30.indexOf(acao) === -1) buckets.dias30.push(acao);
        else if (prazo > 30 && buckets.dias90.indexOf(acao) === -1) buckets.dias90.push(acao);
      }
    });
    if (!buckets.dias7.length || !buckets.dias30.length || !buckets.dias90.length) {
      stageOrder.forEach(code => {
        if (buckets.dias7.length && buckets.dias30.length && buckets.dias90.length) return;
        const stage = out.analiseDetalhada[code];
        if (!stage) return;
        const tip = String(stage.melhoria || '').trim();
        if (!tip) return;
        if (!buckets.dias7.length) buckets.dias7.push(tip);
        else if (!buckets.dias30.length) buckets.dias30.push(tip);
        else if (!buckets.dias90.length) buckets.dias90.push(tip);
      });
    }
    horizon.dias7 = buckets.dias7.slice(0, 4);
    horizon.dias30 = buckets.dias30.slice(0, 4);
    horizon.dias90 = buckets.dias90.slice(0, 4);
  }
  recs.horizonte = horizon;
  out.recomendacoesPraticas = recs;

  out.aspectosGeraisDetalhado = out.aspectosGeraisDetalhado && typeof out.aspectosGeraisDetalhado === 'object'
    ? out.aspectosGeraisDetalhado
    : {};
  const ag = out.aspectosGeraisDetalhado;
  const narrativas = ai_buildNarrativeFeedback_(metodo, rec);
  ag.satisfacoes = narrativas.satisfacoes ? [narrativas.satisfacoes] : [];
  ag.frustracoes = narrativas.frustracoes ? [narrativas.frustracoes] : [];
  out.aspectosGeraisDetalhado = ag;

  return out;
}

function ai_servirStageFallback_(metodo, stageCode, record){
  const spec = ai_getMetodoSpec_(metodo);
  const label = (spec.pillarLabels && spec.pillarLabels[stageCode]) || stageCode;
  const entries = [];

  Object.keys(record || {}).forEach(header => {
    if (ai_pillarFromHeader_(metodo, header) !== stageCode) return;
    const text = ai_servirAnswerText_(record[header]);
    if (!text) return;
    const scoreInfo = ai_answer01_multi_(record[header]);
    entries.push({
      header,
      text,
      score: scoreInfo.count ? scoreInfo.v : null
    });
  });

  if (!entries.length) {
    return {
      comportamentos: [`Sem respostas registradas para ${label}.`],
      impacto: `Não foi possível avaliar ${label.toLowerCase()} por falta de dados.`,
      melhoria: `Coletar mais evidências práticas sobre ${label.toLowerCase()} na próxima visita.`
    };
  }

  const positives = entries.filter(e => e.score == null || e.score >= 0.6);
  const negatives = entries.filter(e => e.score != null && e.score < 0.6);
  const comportamentosSource = (positives.length ? positives : entries).slice(0, 3);
  const comportamentos = comportamentosSource.map(e =>
    `${ai_formatHeaderLabel_(metodo, e.header)} — ${e.text}`
  );

  let impacto = '';
  if (positives.length) {
    const avg = positives.reduce((sum, e) => sum + (e.score != null ? e.score : 0.7), 0) / positives.length;
    impacto = `Evidências positivas (${positives.length}) reforçam ${label.toLowerCase()} com cerca de ${Math.round(avg * 100)}% de aderência.`;
  } else {
    impacto = `Os registros sugerem atenção especial a ${label.toLowerCase()} para evitar lacunas na experiência.`;
  }

  let melhoria = '';
  if (negatives.length) {
    const tips = negatives.slice(0, 3).map(e =>
      `Reforce ${ai_formatHeaderLabel_(metodo, e.header).toLowerCase()} (registro atual: ${e.text}).`
    );
    melhoria = tips.join(' ');
  } else {
    melhoria = `Mantenha os comportamentos atuais de ${label.toLowerCase()} e aprofunde o que já funciona bem.`;
  }

  return { comportamentos, impacto, melhoria };
}

function ai_servirAnswerText_(value){
  if (value == null) return '';
  if (Array.isArray(value)) {
    const items = value.map(ai_servirAnswerText_).filter(Boolean);
    return items.join('; ');
  }
  if (value instanceof Date) {
    return Utilities.formatDate(value, Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm');
  }
  if (typeof value === 'number') {
    return Number.isFinite(value) ? String(value) : '';
  }
  const str = String(value).trim();
  return str;
}

function ai_servirSatisfacoesFallback_(metodo, record){
  const list = [];
  Object.keys(record || {}).forEach(header => {
    const answer = record[header];
    const scoreInfo = ai_answer01_multi_(answer);
    if (!scoreInfo.count || scoreInfo.v < 0.75) return;
    const text = ai_servirAnswerText_(answer);
    if (!text) return;
    list.push(`${ai_formatHeaderLabel_(metodo, header)} — ${text}`);
  });
  return list.slice(0, 5);
}


function ai_buildHtmlReport_SERVIR_(spec, metodo, meta, a, qa){
  const record = qa && qa.record ? qa.record : {};
  a = ai_servirEnsureEnrichment_(metodo, a, record);
  const pilares = a.pilares || {};
  const defs = spec.pillarLabels || {};
  const methodDisplay = spec.display || "SERVIR + GOLD";
  const gold = a.atributosGold || {};

  function escapeHtml_(s){
    const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
    return String(s || "").replace(/[&<>"']/g, function(ch){ return map[ch]; });
  }
  function formatStageLabel_(code){
    const label = defs[code] || code;
    if (code === "R_REC") return "R1 – " + label;
    if (code === "R_REL") return "R2 – " + label;
    return code + " – " + label;
  }

  const dataBR = (function formatDateBr_(iso){
    try{
      let d = iso ? new Date(String(iso).trim()) : null;
      if (iso && /^\d{4}-\d{2}-\d{2}$/.test(String(iso))) d = new Date(String(iso) + "T00:00:00");
      const dt = (d && !isNaN(d)) ? d : new Date();
      const dias  = ["domingo","segunda-feira","terça-feira","quarta-feira","quinta-feira","sexta-feira","sábado"];
      const meses = ["janeiro","fevereiro","março","abril","maio","junho","julho","agosto","setembro","outubro","novembro","dezembro"];
      const dd = String(dt.getDate()).padStart(2,"0");
      return `${dias[dt.getDay()]}, ${dd} de ${meses[dt.getMonth()]} de ${dt.getFullYear()}`;
    }catch(_){ return String(iso||""); }
  })(meta.dataISO);

  const order = spec.pillarOrder || ["S","E","R_REC","V","I","R_REL"];
  const logoSrc = _getLogoDataUrl_() || LOGO_URL;

  function toNumber(val, fallback){
    if (val === null || typeof val === "undefined" || val === "") return fallback;
    const num = Number(val);
    return isNaN(num) ? fallback : num;
  }
  function pctFrom10(val){
    if (!Number.isFinite(val)) return 0;
    return Math.max(0, Math.min(100, Math.round(val * 10)));
  }
  function formatScore(val, digits){
    if (!Number.isFinite(val)) return "—";
    return val.toFixed(digits);
  }
  function pillarStatus(note){
    if (!Number.isFinite(note)) return { cls:"warn", label:"Sem dados" };
    if (note >= 8.5) return { cls:"ok", label:"Excelente" };
    if (note >= 7) return { cls:"warn", label:"Atenção" };
    return { cls:"bad", label:"Crítico" };
  }
  function npsBadge(n){
    if (!Number.isFinite(n)) return { cls:"warn", label:"Sem nota" };
    if (n >= 9) return { cls:"ok", label:"Promotor" };
    if (n >= 7) return { cls:"warn", label:"Neutro" };
    return { cls:"bad", label:"Detrator" };
  }
  function listHtml(items){
    const arr = ensureList_(items).map(escapeHtml_).filter(Boolean);
    if (!arr.length) return "<li>—</li>";
    return arr.map(function(x){ return `<li>${x}</li>`; }).join("");
  }
  function ensureList_(val){
    if (val == null) return [];
    if (Array.isArray(val)) {
      return val.map(function(item){
        if (item == null) return '';
        if (typeof item === 'object') {
          if (typeof item.acao === 'string') return item.acao.trim();
          if (typeof item.text === 'string') return item.text.trim();
          if (typeof item.description === 'string') return item.description.trim();
          if (typeof item.value === 'string') return item.value.trim();
          if (typeof item.mensagem === 'string') return item.mensagem.trim();
        }
        return String(item).trim();
      }).filter(Boolean);
    }
    if (typeof val === 'object') {
      return Object.keys(val).map(function(k){ return String(val[k] || '').trim(); }).filter(Boolean);
    }
    const s = String(val || '').trim();
    return s ? [s] : [];
  }
  function sanitizeFeedback_(text){
    let out = String(text || '').trim();
    if (!out) return '';
    out = out.replace(/^(Falhou|Não atendeu ao esperado|Atendeu ao esperado)\s+em:\s*/i, '');
    const arrowIdx = out.indexOf('→');
    if (arrowIdx !== -1) out = out.slice(arrowIdx + 1).trim();
    out = out.replace(/^Q\d+[.\-\s]*/i, '');
    out = out.replace(/^[A-Z]{1,3}\.\d+\)\s*/,'');
    out = out.replace(/^[A-Z]{1,4}\s*[–-]\s*/,'');
    out = out.replace(/^[•\-–]+\s*/, '');
    out = out.replace(/\s*\([^)]*\)\s*$/, '').trim();
    out = out.replace(/\s*[?!.…]+$/, '').trim();
    if (!/\bdeve\b/i.test(out)) {
      const verbReplacements = [
        { pattern: /\b(perguntou|perguntar)\b/i, replacement: 'deve perguntar' },
        { pattern: /\b(ofereceu|oferecer)\b/i, replacement: 'deve oferecer' },
        { pattern: /\b(apresentou|apresentar)\b/i, replacement: 'deve apresentar' },
        { pattern: /\b(convidou|convidar)\b/i, replacement: 'deve convidar' },
        { pattern: /\b(agradeceu|agradecer)\b/i, replacement: 'deve agradecer' },
        { pattern: /\b(validou|validar)\b/i, replacement: 'deve validar' },
        { pattern: /\b(registrou|registrar)\b/i, replacement: 'deve registrar' },
        { pattern: /\b(explicou|explicar)\b/i, replacement: 'deve explicar' },
        { pattern: /\b(reforçou|reforcar|reforçar)\b/i, replacement: 'deve reforçar' }
      ];
      verbReplacements.forEach(function(rule){
        out = out.replace(rule.pattern, function(match){
          const rep = rule.replacement;
          if (/^[A-ZÁÉÍÓÚÂÊÔÃÕÀÇ]/.test(match)) {
            return rep.charAt(0).toUpperCase() + rep.slice(1);
          }
          return rep;
        });
      });
    }
    if (!out) return '';
    out = out.charAt(0).toUpperCase() + out.slice(1);
    if (!/[.!?]$/.test(out)) out += '.';
    return out;
  }
  function feedbackListHtml(items){
    const arr = ensureList_(items).map(sanitizeFeedback_).filter(Boolean);
    if (!arr.length) return "<li>—</li>";
    return arr.map(function(x){ return `<li>${escapeHtml_(x)}</li>`; }).join("");
  }

  const mediaVal = toNumber(a.media, null);
  const aspectosVal = toNumber(a.aspectosGerais, null);
  const npsVal = toNumber(a.nps, null);
  const mediaCalc = formatScore(mediaVal, 1);
  const aspectos = formatScore(aspectosVal, 1);
  const npsText = formatScore(npsVal, 0);
  const npsInfo = npsBadge(npsVal);

  const se = a.sumarioExecutivo || {};
  const ad = a.analiseDetalhada || {};
  const ag = a.aspectosGeraisDetalhado || {};
  const rp = (a.recomendacoesPraticas && typeof a.recomendacoesPraticas === 'object') ? a.recomendacoesPraticas : {};
  const conclusao = a.conclusao || "";

  const pontosFortesList = ensureList_(a.pontosFortes);
  const pontosFracosList = ensureList_(a.pontosFracos);
  const insightsList = ensureList_(a.insightsEstrategicos);

  const principaisFortes = ensureList_(se.principaisFortes && se.principaisFortes.length ? se.principaisFortes : pontosFortesList);
  const principaisFracos = ensureList_(se.principaisFracos && se.principaisFracos.length ? se.principaisFracos : pontosFracosList);

  const keyTakeaways = [];
  if (se.insightCentral) keyTakeaways.push(String(se.insightCentral));
  if (se.classificacaoRanking) keyTakeaways.push("Classificação: " + se.classificacaoRanking);
  if (!keyTakeaways.length && pontosFortesList.length) keyTakeaways.push(String(pontosFortesList[0]));
  if (!keyTakeaways.length && insightsList.length) keyTakeaways.push(String(insightsList[0]));
  const keyTakeawaysHtml = listHtml(keyTakeaways);
  const fortesResumoHtml = listHtml(principaisFortes.length ? principaisFortes : pontosFortesList);
  const fracosResumoHtml = listHtml(principaisFracos.length ? principaisFracos : pontosFracosList);

  const atributosGoldHtml = (function(){
    const labels = spec.goldAttributes && spec.goldAttributes.labels || {};
    const ordem = spec.goldAttributes && spec.goldAttributes.order || ["G","O","L","D"];
    const cards = ordem.map(function(code){
      const raw = gold[code];
      const num = Number(raw);
      if (!Number.isFinite(num)) return "";
      const pct = Math.max(0, Math.min(100, Math.round(num * 10)));
      const label = labels[code] || code;
      return `<div class="g">
        <div class="tag">${escapeHtml_(code)} – ${escapeHtml_(label)}</div>
        <div class="pct">${num.toFixed(1)}</div>
        <div class="progress"><span style="width:${pct}%"></span></div>
      </div>`;
    }).filter(Boolean).join("");
    if (!cards) return '<div class="muted">Sem indicadores GOLD avaliados nesta visita.</div>';
    return `<div class="gold">${cards}</div>`;
  })();

  const pilaresRows = order.map(function(code){
    const nota = Number(pilares[code]);
    const pct = Number.isFinite(nota) ? pctFrom10(nota) : null;
    const badge = pillarStatus(nota);
    return `<tr>
      <td>${escapeHtml_(formatStageLabel_(code))}</td>
      <td>${formatScore(nota, 1)}</td>
      <td>${pct !== null ? pct + "%" : "—"}</td>
      <td><span class="status ${badge.cls}">${badge.label}</span></td>
    </tr>`;
  }).join("");

  function renderListBlock(items){
    const arr = ensureList_(items);
    if (!arr.length) return '<p class="muted">Sem recomendações registradas.</p>';
    return `<ul class="plain-list">${arr.map(function(s){ return `<li>${escapeHtml_(s)}</li>`; }).join('')}</ul>`;
  }
  function renderPlanRow(label, items){
    const arr = ensureList_(items);
    if (!arr.length) return `<tr><td>${escapeHtml_(label)}</td><td>—</td></tr>`;
    const lis = arr.map(function(s){ return `<li>${escapeHtml_(s)}</li>`; }).join('');
    return `<tr><td>${escapeHtml_(label)}</td><td><ul class="plain-list">${lis}</ul></td></tr>`;
  }
  function feedbackSummaryText(items, fallback){
    const arr = ensureList_(items).map(sanitizeFeedback_).filter(Boolean);
    if (!arr.length) return fallback;
    return arr.join(' ');
  }

  const recsVendedorBlock = renderListBlock(rp.garcom);
  const recsGestorBlock = renderListBlock(rp.gestor);
  const horizon = (rp.horizonte && typeof rp.horizonte === 'object') ? rp.horizonte : {};
  const planTableHtml = `
<table class="plan-table">
  <thead><tr><th>Prazo</th><th>Ações sugeridas</th></tr></thead>
  <tbody>
    ${renderPlanRow('Até 7 dias', horizon.dias7)}
    ${renderPlanRow('Até 30 dias', horizon.dias30)}
    ${renderPlanRow('Até 90 dias', horizon.dias90)}
  </tbody>
</table>`;

  const aspectosTable = (function(){
    const rows = [
      ["Higiene","higiene"],["Simpatia","simpatia"],["Agilidade","agilidade"],["Educação","educacao"],
      ["Atenção","atencao"],["Qualidade dos pratos","qualidadePratos"],["Variedade de bebidas","variedadeBebidas"],
      ["Preço","preco"],["Ambiente","ambiente"]
    ].map(function([label,key]){
      const raw = ag && ag[key] != null && ag[key] !== "" ? Number(ag[key]).toFixed(1) : "—";
      return `<tr><td>${escapeHtml_(label)}</td><td>${raw}</td></tr>`;
    }).join("");
    const satisResumo = feedbackSummaryText(ag.satisfacoes, 'Sem destaques positivos registrados.');
    const frusResumo = feedbackSummaryText(ag.frustracoes, 'Sem pontos de melhoria registrados.');
    return { rows, satisResumo, frusResumo };
  })();

  const satisfacoesResumo = aspectosTable.satisResumo;
  const frustracoesResumo = aspectosTable.frusResumo;
  const insightsHtml = listHtml(insightsList);
  const sintese = a.sinteseComentarios ? `<div class="muted" style="margin-top:12px;">${escapeHtml_(a.sinteseComentarios)}</div>` : '';

  const qaHtml = (function(){
    if (!qa || !qa.headers || !qa.record) return '<tr><td colspan="2">—</td></tr>';
    const ignoreTokens = [
      'respondent id','collector id','collector name','language','start date','end date','time spent','ip address',
      'email address','first name','last name','voucher','job id','job_id','user email','user_email','empresaid','company id','companyid'
    ];
    const clean = function(s){
      return String(s||'')
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/^custom (variable|variables):\s*/i,'')
        .replace(/[_:]+/g,' ')
        .trim().toLowerCase();
    };
    const rows = [];
    for (let i=0;i<qa.headers.length;i++){
      const hRaw = qa.headers[i];
      const vRaw = qa.record[hRaw];
      const h = clean(hRaw);
      const v = String(vRaw||'').trim();
      if (!v) continue;
      if (ignoreTokens.some(function(tok){ return h.includes(tok); })) continue;
      rows.push(`<tr><td><b>${escapeHtml_(hRaw)}</b></td><td>${escapeHtml_(v)}</td></tr>`);
    }
    return rows.length ? rows.join('') : '<tr><td colspan="2">—</td></tr>';
  })();

  return `
<!DOCTYPE html><html><head><meta charset="utf-8"/>
<style>
  :root{
    --bg:#F7F9FB; --panel:#FFFFFF; --ink:#0B1F22; --muted:#5B6B73; --line:#E6ECEF;
    --brand:#0EA5E9; --ok:#16A34A; --warn:#F59E0B; --bad:#EF4444;
    --radius:14px; --shadow:none;
  }
  *{box-sizing:border-box;}
  body{ font-family: Inter,Arial,"Helvetica Neue",sans-serif; color:var(--ink); background:var(--bg); margin:0; padding:34px; -webkit-print-color-adjust:exact; print-color-adjust:exact; }
  .page{ max-width:960px; margin:0 auto; }
  h1{ font-size:28px; margin:0; line-height:1.2; }
  h2{ font-size:18px; margin:22px 0 10px; color:#0F2E34; }
  .muted{ color:var(--muted); }
  .badge{ display:inline-flex; align-items:center; gap:8px; padding:7px 12px; border-radius:999px; font-size:12px; background:#E0F2FE; color:#0F2E34; font-weight:600; }
  .header{ display:flex; justify-content:space-between; align-items:center; gap:20px; }
  .header-info{ display:flex; flex-direction:column; gap:6px; }
  .meta{ color:var(--muted); font-size:13px; }
  .logo img{ height:40px; display:block; }
  .kpis{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px; margin-top:22px; }
  .kpi{ background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:14px; box-shadow:none; }
  .kpi .label{ color:var(--muted); font-size:12px; margin-bottom:6px; text-transform:uppercase; letter-spacing:.05em; }
  .kpi .value{ font-size:24px; font-weight:700; }
  .progress{ height:10px; background:#EFF4F7; border-radius:999px; overflow:hidden; margin-top:10px; }
  .progress span{ display:block; height:100%; background:linear-gradient(90deg,var(--brand),#38BDF8); }
  .status{ font-size:12px; font-weight:600; padding:4px 10px; border-radius:999px; display:inline-block; }
  .status.ok{ background:rgba(22,163,74,.12); color:var(--ok); }
  .status.warn{ background:rgba(245,158,11,.12); color:var(--warn); }
  .status.bad{ background:rgba(239,68,68,.12); color:var(--bad); }
  .card{ background:var(--panel); border-radius:var(--radius); border:1px solid var(--line); box-shadow:none; overflow:hidden; margin-top:24px; }
  .card .hd{ padding:14px 16px; border-bottom:1px solid var(--line); background:#F1F5F9; font-weight:600; }
  .card .bd{ padding:16px 20px; }
  .stack-cards{ display:flex; flex-direction:column; gap:12px; }
  .stack-cards .subcard{ background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:14px; }
  .stack-cards .subcard-title{ font-weight:600; color:#0F2E34; margin-bottom:6px; }
  .grid{ display:grid; gap:16px; }
  .grid.cols-3{ grid-template-columns:repeat(3,minmax(0,1fr)); }
  table{ width:100%; border-collapse:collapse; font-size:14px; background:var(--panel); border-radius:12px; overflow:hidden; }
  thead th{ background:#F1F5F9; font-weight:600; padding:10px 12px; border-bottom:1px solid var(--line); text-align:left; }
  tbody td{ padding:10px 12px; border-bottom:1px solid var(--line); }
  .gold{ display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:12px; margin-top:12px; }
  .gold .g{ background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; box-shadow:none; }
  .gold .g .tag{ font-weight:700; font-size:13px; }
  .gold .g .pct{ font-size:22px; font-weight:700; margin-top:6px; }
  .plan-table{ width:100%; border-collapse:collapse; margin-top:10px; border-radius:12px; overflow:hidden; }
  .plan-table th, .plan-table td{ border:1px solid var(--line); padding:10px 12px; text-align:left; vertical-align:top; background:#FFFFFF; }
  .plan-table th{ background:#F1F5F9; font-weight:600; }
  .plain-list{ margin:0; padding-left:20px; }
  .plain-list li{ margin-bottom:4px; }
  .section{ margin-top:28px; }
  .summary-card{ margin-top:16px; }
  .summary-card .bd{ padding:16px 20px; }
  .summary-card .bd p{ margin:0; white-space:pre-line; }
  .page-break{ page-break-before:always; }
  .commentary{ background:#F5F6F7; border-radius:16px; padding:18px 22px; margin-top:24px; }
  .commentary table{ width:100%; border-collapse:collapse; margin-top:12px; }
  .commentary td{ padding:8px 10px; border:1px solid #E5E7EB; background:#fff; }
  .footer{ margin-top:24px; color:var(--muted); font-size:12px; display:flex; justify-content:space-between; }
  @page{ size:A4; margin:18mm 15mm; }
  @media print{ body{ background:#fff; padding:0; } .page{ max-width:none; } .card{ box-shadow:none; } }
</style></head>
<body>
  <div class="page">
    <div class="header">
      <div class="header-info">
        <span class="badge">${escapeHtml_(methodDisplay)}</span>
        <h1>${escapeHtml_(meta.estabelecimento||"Avaliação")}</h1>
        <div class="meta">Visita em ${escapeHtml_(dataBR)} • Job ${escapeHtml_(meta.jobId||"—")} • Voucher ${escapeHtml_(meta.voucher||"—")}</div>
      </div>
      <div class="logo"><img src="${logoSrc}" alt="SuperSeller" /></div>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="label">Média SERVIR</div>
        <div class="value">${mediaCalc}</div>
        <div class="progress"><span style="width:${pctFrom10(mediaVal)}%"></span></div>
      </div>
      <div class="kpi">
        <div class="label">Aspectos gerais</div>
        <div class="value">${aspectos}</div>
        <div class="progress"><span style="width:${pctFrom10(aspectosVal)}%"></span></div>
      </div>
      <div class="kpi">
        <div class="label">NPS</div>
        <div class="value">${npsText}</div>
        <div class="status ${npsInfo.cls}" style="margin-top:10px;">${npsInfo.label}</div>
      </div>
    </div>

    <div class="card">
      <div class="hd">Sumário executivo</div>
      <div class="bd">
        <div class="grid cols-3">
          <div>
            <h2>Pontos-chave</h2>
            <ul>${keyTakeawaysHtml}</ul>
          </div>
          <div>
            <h2>Forças</h2>
            <ul>${fortesResumoHtml}</ul>
          </div>
          <div>
            <h2>Fragilidades</h2>
            <ul>${fracosResumoHtml}</ul>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Etapas do SERVIR (nota & acerto)</h2>
      <div class="card" style="margin-top:10px;">
        <div class="bd" style="padding:0;">
          <table>
            <thead><tr><th>Etapa</th><th>Nota (0–10)</th><th>Acerto (%)</th><th>Status</th></tr></thead>
            <tbody>${pilaresRows}</tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Atributos GOLD</h2>
      ${atributosGoldHtml}
    </div>

    <div class="section">
      <h2>Recomendações práticas</h2>
      <div class="card">
        <div class="bd">
          <div class="stack-cards">
            <div class="subcard">
              <div class="subcard-title">Para o Vendedor</div>
              ${recsVendedorBlock}
            </div>
            <div class="subcard">
              <div class="subcard-title">Para o Gestor</div>
              ${recsGestorBlock}
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Plano de ação</h2>
      <div class="card">
        <div class="bd">
          ${planTableHtml}
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Aspectos gerais</h2>
      <div class="card">
        <div class="hd">Notas detalhadas</div>
        <div class="bd" style="padding:0;">
          <table><tbody>${aspectosTable.rows}</tbody></table>
        </div>
      </div>
      <div class="card summary-card">
        <div class="hd">Satisfações</div>
        <div class="bd"><p>${escapeHtml_(satisfacoesResumo)}</p></div>
      </div>
      <div class="card summary-card">
        <div class="hd">Frustrações</div>
        <div class="bd"><p>${escapeHtml_(frustracoesResumo)}</p></div>
      </div>
    </div>

    ${conclusao ? `<div class="section"><div class="card" style="margin-top:0;"><div class="hd">Conclusão</div><div class="bd"><p>${escapeHtml_(conclusao)}</p></div></div></div>` : ''}

    ${insightsList.length ? `<div class="section"><div class="card" style="margin-top:0;"><div class="hd">Insights estratégicos</div><div class="bd"><ul>${insightsHtml}</ul></div></div></div>` : ''}

    <div class="footer">
      <div>Relatório gerado automaticamente pela IA SuperSeller — ${escapeHtml_(methodDisplay)}</div>
      <div>${escapeHtml_(meta.dataISO || meta.data || "")}</div>
    </div>
  </div>

  <div class="page page-break">
    <h2>Detalhamento SERVIR</h2>
    <div class="commentary">
      <table>
        <tr><th>Etapa</th><th>Comportamentos observados</th><th>Impacto na experiência</th><th>Oportunidades</th></tr>
        ${order.map(function(code){
          const etapa = ad[code] || {};
          const comp = listHtml(etapa.comportamentos);
          const impact = escapeHtml_(etapa.impacto || "—");
          const melhoria = escapeHtml_(etapa.melhoria || "—");
          return `<tr>
            <td style="font-weight:600;">${escapeHtml_(formatStageLabel_(code))}</td>
            <td><ul>${comp}</ul></td>
            <td>${impact}</td>
            <td>${melhoria}</td>
          </tr>`;
        }).join('')}
      </table>
    </div>

    <div class="commentary">
      <h2>Respostas do avaliador</h2>
      ${sintese}
      <table>${qaHtml}</table>
    </div>
  </div>
</body></html>`;
}

function ai_writeAndNotify_(empresaId, metodo, meta, analysisObj, qa){
  const sh = ai_getAnalisesSheet_();

  const mediaRecalc = ai_calcMedia_(metodo, analysisObj.pilares || {});
  const media = (analysisObj.media!=null && !isNaN(Number(analysisObj.media))) ? Number(analysisObj.media) : mediaRecalc;
  const aspectos = (analysisObj.aspectosGerais==null||analysisObj.aspectosGerais==='')?null:Number(analysisObj.aspectosGerais);
  const nps = (analysisObj.nps==null||analysisObj.nps==='')?null:Number(analysisObj.nps);

  const pdf = ai_renderPdf_(empresaId, metodo, meta, { ...analysisObj, media }, qa);
  const pdfUrl = pdf && pdf.url ? pdf.url : '';

  let to = '';
  try {
    const emp = admin_getCompanyById_(empresaId);
    to = (emp && emp.relatorioEmail) ? String(emp.relatorioEmail) : String(emp && emp.gerenteEmail || '');
  } catch(_) {}

  sh.appendRow([
    new Date(), empresaId, metodo, meta.jobId||'', meta.voucher||'', (meta.user_email||'').toLowerCase(), meta.dataISO||'',
    analysisObj.avaliado||'',
    JSON.stringify(analysisObj.pilares || {}, null, 0),
    JSON.stringify(analysisObj.atributosGold || {}, null, 0),
    Number(media), aspectos, nps,
    (analysisObj.pontosFortes||[]).join(' • '),
    (analysisObj.pontosFracos||[]).join(' • '),
    (analysisObj.planoAcao||[]).map(p=>'- '+(p.acao||p)).join('\n'),
    pdfUrl, to, ''
  ]);
  const outRow = sh.getLastRow();

  // ===== Novo assunto e corpo do e-mail com nome do avaliado + assinatura =====
  const avaliadoNome = String(analysisObj.avaliado || '').trim();
  const metodoDisplay = ai_getMetodoSpec_(metodo).display || String(metodo || '').toUpperCase();
  const assunto = `Relatório da avaliação ${avaliadoNome || meta.jobId || ''} – ${metodoDisplay}`;
  const corpoTxt = `Segue em anexo o relatório da avaliação ${avaliadoNome || meta.jobId || ''}.\n\nAtenciosamente,\n\nEquipe SuperSeller`;
  const corpoHtml =
    '<div style="font-family:Inter,Segoe UI,Arial,sans-serif;line-height:1.5;color:#0f2e34">' +
      `<p>Segue em anexo o relatório da avaliação ${avaliadoNome || meta.jobId || ''}.</p>` +
      '<p>Atenciosamente,</p>' +
      '<p>Equipe SuperSeller</p>' +
      `<p><img src="${LOGO_URL}" alt="SuperSeller" width="200" style="display:block;margin:0;max-width:200px;width:54%;height:auto;"/></p>` +
    '</div>';

  if (to && pdf && pdf.blob) {
    try {
      GmailApp.sendEmail(to, assunto, corpoTxt, {
        htmlBody: corpoHtml,
        attachments: [pdf.blob],
        ..._emailOpts_()
      });
      sh.getRange(outRow, sh.getLastColumn()).setValue(new Date()); // sentAt
    } catch(e){
      Logger.log('[AI] Erro ao enviar email (GmailApp): '+e);
      try {
        MailApp.sendEmail({
          to,
          subject: assunto,
          htmlBody: corpoHtml,
          name: EMAIL_NAME,
          replyTo: EMAIL_FROM,
          attachments: [pdf.blob]
        });
        sh.getRange(outRow, sh.getLastColumn()).setValue(new Date());
      } catch(e2){ Logger.log('[AI] Falha MailApp: '+e2); }
    }
  }

  return { row: outRow, pdfUrl };
}

/** ======= Processa UM item da fila ======= */
function ai_processOne_(args){
  const { empresaId, tabName, jobId, voucher, user_email, respondentId } = args;
  const cfg = ai_getConfig_(empresaId);
  const effectiveTab = cfg.tabNameOverride || tabName;

  // meta complementares vindas da aba AvaliacoesAtribuidas
  const meta = { empresaId, jobId, voucher, user_email, respondentId, dataISO: '', estabelecimento: '' };
  try { const shA = getAvaliacoesSheet_(); const colA = getHeaderMap_(shA); const last = shA.getLastRow();
    if (last>=2 && colA.jobId){
      const vals = shA.getRange(2, colA.jobId, last-1, 1).getValues().flat();
      const idx = vals.findIndex(v => String(v)===String(jobId));
      if (idx !== -1){
        const row = idx+2; meta.dataISO = String(colA.dataISO?shA.getRange(row,colA.dataISO).getValue():''); meta.estabelecimento = String(colA.estabelecimento?shA.getRange(row,colA.estabelecimento).getValue():'');
      }
    }
  } catch(_) {}

  // SM → registro bruto
  const { headers, record } = ai_buildCaseFromSM_(empresaId, effectiveTab, respondentId);
  const metodo = ai_decideMethod_(empresaId);

  // Cálculo determinístico: notas por pilar + aspectos fixos
  const calc = ai_computeDeterministico_(metodo, record, cfg);
  meta.goldBuckets = ai_groupHeadersByGold_(metodo, record);
  meta.atributosGold = calc.atributosGold || {};

  // Prompt/LLM (gera texto e recomendações)
  const { prompt, schemaStr } = ai_buildPrompt_(metodo, meta, record, cfg);
  let analysis = null;
  try { analysis = ai_callLLM_(prompt, schemaStr); }
  catch(e){
    Logger.log('[AI] LLM error: '+e);
    analysis = { empresaId, metodo, jobId, voucher, user_email, avaliado:'', pilares:{}, media:0, aspectosGerais:null, nps:null, pontosFortes:[], pontosFracos:[], planoAcao:[], atributosGold:{} };
  }

  // saneia e MESCLA com o cálculo determinístico (o calculado prevalece)
  analysis.empresaId = analysis.empresaId || empresaId;
  analysis.metodo    = analysis.metodo || metodo;
  analysis.jobId     = analysis.jobId || jobId;
  analysis.voucher   = analysis.voucher || voucher;
  analysis.user_email= (analysis.user_email || user_email || '').toLowerCase();

  analysis.pilares = { ...(analysis.pilares||{}), ...(calc.pilares||{}) };
  if (calc.aspectosGerais != null) analysis.aspectosGerais = calc.aspectosGerais;
  if (calc.nps != null) analysis.nps = calc.nps;
  analysis.atributosGold = { ...(analysis.atributosGold||{}), ...(calc.atributosGold||{}) };

  // média final ajustada ao método selecionado
  analysis.media = ai_calcMedia_(metodo, analysis.pilares);
  // ==== Força "avaliado" a ser um nome de pessoa (garçom/vendedor/atendente), nunca o estabelecimento
  try {
    var avaliadoExtraido = ai_extractAvaliadoFromRecord_(record, meta.estabelecimento||'');
    if (avaliadoExtraido) {
      analysis.avaliado = avaliadoExtraido;
    } else if (String(analysis.avaliado||'').trim() && String(analysis.avaliado||'').trim() === String(meta.estabelecimento||'').trim()) {
      // se IA devolveu o nome da empresa, zere
      analysis.avaliado = '';
    }
  } catch(_){}


  // força nota geral no sumário a refletir a média (0..10 -> 0..100%)
  analysis.sumarioExecutivo = analysis.sumarioExecutivo || {};
  analysis.sumarioExecutivo.notaGeralPercentual = Math.round(Number(analysis.media || 0) * 10);

  // Fallbacks locais com base nas negativas detectadas
  const negByP = ai_listNegativesByPilar_(metodo, record);
  const spec = ai_getMetodoSpec_(metodo);

  // Pontos fracos: se vier vazio, derive dos títulos das negativas
  if (!analysis.pontosFracos || !analysis.pontosFracos.length) {
    const keys = spec.weaknessFallback || Object.keys(negByP || {});
    const flatNeg = (keys || []).reduce((acc, key) => acc.concat(negByP[key] || []), []);
    analysis.pontosFracos = flatNeg.map(h => `Falhou em: ${ai_formatHeaderLabel_(metodo, h)}`).slice(0, 6);
  }

  // Frustrações (em Aspectos Gerais): cria se vier vazio
  analysis.aspectosGeraisDetalhado = analysis.aspectosGeraisDetalhado || {};
  if (!Array.isArray(analysis.aspectosGeraisDetalhado.frustracoes) ||
      !analysis.aspectosGeraisDetalhado.frustracoes.length) {
    const frKeys = spec.frustrationFallback || Object.keys(negByP || {});
    const fr = (frKeys || []).reduce((acc, key) => acc.concat(negByP[key] || []), [])
                .map(h => `Não atendeu ao esperado em: ${ai_formatHeaderLabel_(metodo, h)}`);
    analysis.aspectosGeraisDetalhado.frustracoes = fr.slice(0, 6);
  }

  // (opcional) classificação coerente com a %:
  if (!analysis.sumarioExecutivo.classificacaoRanking) {
    const pct = analysis.sumarioExecutivo.notaGeralPercentual;
    analysis.sumarioExecutivo.classificacaoRanking =
      pct >= 90 ? 'Excelente' :
      pct >= 75 ? 'Bom' :
      pct >= 60 ? 'Regular' : 'Crítico';
  }

  const out = ai_writeAndNotify_(empresaId, metodo, meta, analysis, { headers, record });
  return { ok:true, out };
}

/** ======= Processa fila ======= */
function ai_processQueue_(){
  const qsh = ai_getQueueSheet_();
  const last = qsh.getLastRow();
  if (last < 2) { Logger.log('[AI] Fila vazia'); return { processed: 0 }; }

  const take = Math.min(10, last-1);
  const rows = qsh.getRange(2,1,take,qsh.getLastColumn()).getValues();
  let processed = 0;
  const toDelete = [];

  for (let i=0; i<rows.length; i++){
    const r = rows[i];
    try {
      const payload = {
        empresaId:  String(r[1]||'').trim(), tabName: String(r[2]||'').trim(), jobId: String(r[3]||'').trim(),
        voucher: String(r[4]||'').trim(), user_email: String(r[5]||'').trim().toLowerCase(),
        respondentId: String(r[6]||'').trim(), evalRow: Number(r[7]||0)
      };
      ai_processOne_(payload);
      processed++;
      toDelete.push(i+2);
    } catch(e){ Logger.log('[AI] Falha processando item da fila: '+e); }
  }
  toDelete.sort((a,b)=>b-a).forEach(row => { try { qsh.deleteRow(row); } catch(_){} });
  return { processed };
}

/** ======= Gatilho (5 min) / Autorizador ======= */
function ai_installQueueTriggerEvery5min(){
  ScriptApp.getProjectTriggers().forEach(t=>{ if (t.getHandlerFunction() === 'ai_processQueue_') ScriptApp.deleteTrigger(t); });
  ScriptApp.newTrigger('ai_processQueue_').timeBased().everyMinutes(5).create();
}
function ai_authorize_now() {
  UrlFetchApp.fetch('https://www.google.com', { muteHttpExceptions: true });
  DriveApp.getRootFolder().getId();
  MailApp.getRemainingDailyQuota();
  try { GmailApp.getAliases(); } catch(_) {}
  Logger.log('OK - permissões tocadas (UrlFetch, Drive, Mail e Gmail).');
}
/** Aliases visíveis no seletor */
function AI_ProcessarFila_Agora(){ return ai_processQueue_(); }
function AI_InstalarGatilho_5min(){ return ai_installQueueTriggerEvery5min(); }

/** Ping básico para o Admin.html */
function admin_backendStatus(){
  return { result:'ok', version: (typeof VERSION!=='undefined'?VERSION:'?'), time: new Date() };
}


function admin_listUsers() {
  // abre a planilha diretamente (sem depender de ss_())
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sh =
    ss.getSheetByName('Usuários') ||
    ss.getSheetByName('Usuarios') ||
    ss.getSheetByName('Users');
  if (!sh) return [];

  const lastRow = sh.getLastRow(), lastCol = sh.getLastColumn();
  if (lastRow < 2 || lastCol < 1) return [];

  const vals = sh.getRange(1, 1, lastRow, lastCol).getValues();

  // normalizador de header
  const norm = s => String(s || '')
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .toLowerCase().replace(/[^a-z0-9]+/g, '');

  const head = vals[0].map(norm);
  const find = (arr) => {
    for (const k of arr.map(norm)) {
      const i = head.indexOf(k);
      if (i >= 0) return i;
    }
    return -1;
  };

  const iNome  = find(['nome','name']);
  const iEmail = find(['email','e-mail','mail']);
  const iTel   = find(['telefone','phone','celular','whatsapp']);
  const iAvg   = find(['ratingavg','media','média','mediageral']);
  const iCnt   = find(['ratingcount','avaliacoes','avaliações','qtdavaliacoes']);

  const out = [];
  for (let r = 1; r < vals.length; r++) {
    const row = vals[r];
    const email = String(iEmail >= 0 ? row[iEmail] : '').trim().toLowerCase();
    if (!email) continue;
    out.push({
      nome:        iNome >= 0 ? row[iNome] : '',
      email,
      telefone:    iTel  >= 0 ? row[iTel]  : '',
      ratingAvg:   iAvg  >= 0 && row[iAvg] !== '' ? Number(row[iAvg]) : null,
      ratingCount: iCnt  >= 0 && row[iCnt] !== '' ? Number(row[iCnt]) : null,
    });
  }
  return out;
}
/** -------------------- AVALIADORES — Helpers de cabeçalho -------------------- */
function ensureUsersHeader_(){
  const sh = getSheet();
  const must = [
    'Timestamp','Nome','E-mail','Telefone','Cidade','UF','CPF',
    'Sexo','Renda','FilhosMenores','Escolaridade','Interesses',
    'Salt','Hash','Verified','VerifyToken','VerifyExpires','ResetToken','ResetExpires'
  ];
  if (sh.getLastRow() === 0) {
    sh.appendRow(must);
  } else {
    const headers = sh.getRange(1,1,1, Math.max(1, sh.getLastColumn())).getValues()[0];
    const have = headers.map(h => _norm_(h));
    must.forEach(label=>{
      if (!have.includes(_norm_(label))) {
        sh.insertColumnAfter(sh.getLastColumn());
        sh.getRange(1, sh.getLastColumn()).setValue(label);
      }
    });
  }
  return sh;
}

function getHeaderMapUsersFull_(sh){
  const headers = sh.getRange(1,1,1, sh.getLastColumn()).getValues()[0];
  const hmap = {}; headers.forEach((h,i)=>{ hmap[_norm_(h)] = i+1; });

  function col(/*aliases*/){
    for (var i=0;i<arguments.length;i++){
      var k = _norm_(arguments[i]);
      if (hmap[k]) return hmap[k];
    }
    return null;
  }

  return {
    timestamp: col('Timestamp','Data','CriadoEm'),
    nome: col('Nome','Name'),
    email: col('E-mail','Email','Mail'),
    telefone: col('Telefone','Celular'),
    cidade: col('Cidade'),
    uf: col('UF','Estado'),
    cpf: col('CPF'),
    sexo: col('Sexo','Genero','Gênero'),
    renda: col('Renda'),
    filhosMenores: col('FilhosMenores','Filhos','Criancas','Crianças'),
    escolaridade: col('Escolaridade'),
    interesses: col('Interesses'),
    salt: col('Salt'),
    hash: col('Hash'),
    verified: col('Verified','Verificado'),
    verifyToken: col('VerifyToken'),
    verifyExpires: col('VerifyExpires'),
    resetToken: col('ResetToken'),
    resetExpires: col('ResetExpires')
  };
}

/** -------------------- AVALIADORES — Upsert individual -------------------- */
function admin_upsertUser(payload){
  try{
    const p = payload || {};
    const email = String(p.email||'').trim().toLowerCase();
    const nome  = String(p.nome||'').trim();
    if (!email || !/\S+@\S+\.\S+/.test(email)) return ok_({result:'error', message:'E-mail inválido.'});
    if (!nome) return ok_({result:'error', message:'Nome é obrigatório.'});

    // CPF para regra da senha
    const cpfDigits = String(p.cpf||'').replace(/\D/g,'');
    if (cpfDigits.length < 5) return ok_({result:'error', message:'CPF inválido (mínimo 5 dígitos para gerar senha).'});

    const sh  = ensureUsersHeader_();
    const col = getHeaderMapUsersFull_(sh);
    const last = sh.getLastRow();
    const vals = last>=2 ? sh.getRange(2,1,last-1, sh.getLastColumn()).getValues() : [];

    // ---- unicidade por e-mail (chave primária) ----
    let row = -1, seen = 0;
    for (var i=0;i<vals.length;i++){
      const em = String(vals[i][col.email-1]||'').trim().toLowerCase();
      if (em === email){
        seen++;
        if (row === -1) row = i + 2;  // guarda a 1ª ocorrência
      }
    }
    if (seen > 1) {
      return ok_({
        result:'error',
        code:'EMAIL_NOT_UNIQUE',
        message:'E-mail duplicado na planilha (chave primária). Corrija os registros duplicados antes de prosseguir.'
      });
    }
    // Bloqueia criação quando já existe e não foi solicitado update explícito
    if (row > 0 && !p.allowUpdate) {
      return ok_({ result:'duplicate_email', message:'Já existe um cadastro com este e-mail.' });
    }

    const headers = sh.getRange(1,1,1, sh.getLastColumn()).getValues()[0];
    const line = row>0 ? sh.getRange(row,1,1,sh.getLastColumn()).getValues()[0] : new Array(headers.length).fill('');
    const set = (k,v)=>{ if (col[k]) line[col[k]-1] = v; };

    // Campos básicos
    if (row<0) set('timestamp', new Date());
    set('nome', nome);
    set('email', email);
    set('telefone', String(p.telefone||''));
    set('cidade', String(p.cidade||''));
    set('uf', String(p.uf||'').toUpperCase());
    set('cpf', cpfDigits);
    set('sexo', String(p.sexo||''));
    set('renda', String(p.renda||''));
    set('filhosMenores', String(p.filhosMenores||''));
    set('escolaridade', String(p.escolaridade||''));
    set('interesses', String(p.interesses||''));

    // ----- credenciais (re)geradas apenas quando necessário -----
    const currentCpf = (row>0 && col.cpf) ? String(sh.getRange(row, col.cpf).getValue()||'') : '';
    const cpfChanged = (String(currentCpf).replace(/\D/g,'') !== cpfDigits);
    const mustResetCreds = (row<0) || cpfChanged || (p.forceResetPassword === true);

    if (mustResetCreds){
      const senha  = cpfDigits.slice(-5);          // últimos 5 do CPF
      const salt   = makeSalt();                   // mesmo gerador do signup
      const pepper = getPepper();                  // já existe no seu código
      const hash   = sha256Hex(senha + '|' + salt + '|' + pepper); // mesma ordem do login

      set('salt', salt);
      set('hash', hash);
      set('verified', true); // boolean -> TRUE
      set('verifyToken',''); set('verifyExpires','');
      set('resetToken','');  set('resetExpires','');
    }

    if (row>0) sh.getRange(row,1,1, line.length).setValues([line]);
    else       sh.appendRow(line);

    return ok_({result: row>0 ? 'updated' : 'ok', item:{email}});
  } catch(err){
    return ok_({result:'error', message:String(err)});
  }
}

/** -------------------- AVALIADORES — Get detalhado por e-mail -------------------- */
function admin_getUser(emailRaw){
  const email = String(emailRaw||'').trim().toLowerCase();
  if (!email) return null;
  const sh = ensureUsersHeader_();
  const col = getHeaderMapUsersFull_(sh);
  const last = sh.getLastRow();
  if (last < 2) return null;
  const vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();
  for (var i=0;i<vals.length;i++){
    const row = vals[i];
    if (String(row[col.email-1]||'').toLowerCase() === email){
      return {
        nome: row[col.nome-1]||'',
        email: email,
        telefone: col.telefone? row[col.telefone-1] : '',
        cidade: col.cidade? row[col.cidade-1] : '',
        uf: col.uf? row[col.uf-1] : '',
        cpf: col.cpf? row[col.cpf-1] : '',
        sexo: col.sexo? row[col.sexo-1] : '',
        renda: col.renda? row[col.renda-1] : '',
        filhosMenores: col.filhosMenores? row[col.filhosMenores-1] : '',
        escolaridade: col.escolaridade? row[col.escolaridade-1] : '',
        interesses: col.interesses? row[col.interesses-1] : ''
      };
    }
  }
  return null;
}

/** -------------------- AVALIADORES — Importação CSV em lote -------------------- */
function admin_importUsersCSV(csvText){
  try{
    if (!csvText) return ok_({result:'error', message:'CSV vazio.'});

    // Detecta delimitador e parseia
    const nonEmptyLine = (csvText.split(/\r?\n/).find(l => l.trim().length>0) || '');
    const delim = (nonEmptyLine.match(/;/g)||[]).length > (nonEmptyLine.match(/,/g)||[]).length ? ';' : ',';
    let rows = Utilities.parseCsv(csvText, delim).filter(r => r && r.join('').trim() !== '');
    if (!rows.length) return ok_({result:'error', message:'Sem linhas no CSV.'});

    // Header
    const headerRaw = rows.shift();
    const headers = headerRaw.map(h=> _norm_(h));
    const idx = (...aliases) => {
      for (var i=0;i<aliases.length;i++){
        const j = headers.indexOf(_norm_(aliases[i]));
        if (j >= 0) return j;
      }
      return -1;
    };

    // Campos (email e cpf são obrigatórios para a importação)
    const jNome  = idx('nome','name');
    const jEmail = idx('email','e-mail','mail');
    const jCPF   = idx('cpf');
    const jTel   = idx('telefone','celular','phone','whatsapp');
    const jCid   = idx('cidade');
    const jUF    = idx('uf','estado');
    const jSexo  = idx('sexo','genero','gênero');
    const jRenda = idx('renda');
    const jFilhos= idx('filhosmenores','filhos','criancas','crianças');
    const jEscol = idx('escolaridade');
    const jInts  = idx('interesses');

    if (jEmail < 0) return ok_({result:'error', code:'MISSING_EMAIL_COLUMN', message:'Coluna "Email" ausente no CSV.'});
    if (jCPF   < 0) return ok_({result:'error', code:'MISSING_CPF_COLUMN',   message:'Coluna "CPF" ausente no CSV (necessária para gerar a senha).'});

    // -------- PRECHECK 1: Duplicatas no CSV --------
    const csvCount = {};
    rows.forEach(r=>{
      const em = String(r[jEmail]||'').trim().toLowerCase();
      if (em) csvCount[em] = (csvCount[em]||0) + 1;
    });
    const dupCsv = Object.keys(csvCount).filter(e => csvCount[e] > 1);
    if (dupCsv.length){
      return ok_({
        result:'error',
        code:'CSV_DUPLICATE_EMAILS',
        message:'Existem e-mails duplicados no CSV. Corrija e tente novamente.',
        duplicates: dupCsv.slice(0, 20)
      });
    }

    // -------- PRECHECK 2: Duplicatas na planilha --------
    const sh  = ensureUsersHeader_();
    const col = getHeaderMapUsersFull_(sh);
    const last = sh.getLastRow();
    const vals = last>=2 ? sh.getRange(2,1,last-1, sh.getLastColumn()).getValues() : [];
    const email2row = {};
    const dupSheet = new Set();
    for (var i=0;i<vals.length;i++){
      const em = String(vals[i][col.email-1]||'').trim().toLowerCase();
      if (!em) continue;
      if (email2row[em]) dupSheet.add(em);
      else email2row[em] = i+2;
    }
    if (dupSheet.size){
      return ok_({
        result:'error',
        code:'SHEET_DUPLICATE_EMAILS',
        message:'Há e-mails duplicados na aba "Usuários". Remova/una antes de importar.',
        duplicates: Array.from(dupSheet).slice(0, 20)
      });
    }

    // Importação (agora segura quanto à unicidade)
    const headersOut = sh.getRange(1,1,1, sh.getLastColumn()).getValues()[0];
    let inserted=0, updated=0, errors=0, sampleErr='';

    rows.forEach((r,idxRow)=>{
      try{
        const payload = {
          nome:  jNome>=0 ? r[jNome] : '',
          email: jEmail>=0? String(r[jEmail]||'').trim().toLowerCase() : '',
          cpf:   jCPF>=0 ? r[jCPF] : '',
          telefone: jTel>=0? r[jTel] : '',
          cidade:   jCid>=0? r[jCid] : '',
          uf:       jUF>=0 ? r[jUF] : '',
          sexo:     jSexo>=0? r[jSexo] : '',
          renda:    jRenda>=0? r[jRenda] : '',
          filhosMenores: jFilhos>=0? r[jFilhos] : '',
          escolaridade:  jEscol>=0? r[jEscol]  : '',
          interesses:    jInts>=0 ? r[jInts]   : ''
        };

        // valida mínimos da linha
        if (!payload.email || !/\S+@\S+\.\S+/.test(payload.email)) throw new Error('E-mail inválido');
        const cpfDigits = String(payload.cpf||'').replace(/\D/g,'');
        if (cpfDigits.length < 5) throw new Error('CPF inválido (mín. 5 dígitos)');
        const senha  = cpfDigits.slice(-5);
        const salt   = makeSalt();
        const pepper = getPepper();
        const hash   = sha256Hex(senha + '|' + salt + '|' + pepper);

        // decide inserir/atualizar (já garantido que não há duplicatas na planilha)
        let row = email2row[payload.email] || -1;
        const line = row>0
          ? sh.getRange(row,1,1, sh.getLastColumn()).getValues()[0]
          : new Array(headersOut.length).fill('');

        function set(k,v){ if (col[k]) line[col[k]-1] = v; }

        if (row<0) set('timestamp', new Date());
        set('nome', String(payload.nome||''));
        set('email', payload.email);
        set('telefone', String(payload.telefone||''));
        set('cidade', String(payload.cidade||''));
        set('uf', String(payload.uf||'').toUpperCase());
        set('cpf', cpfDigits);
        set('sexo', String(payload.sexo||''));
        set('renda', String(payload.renda||''));
        set('filhosMenores', String(payload.filhosMenores||''));
        set('escolaridade', String(payload.escolaridade||''));
        set('interesses', String(payload.interesses||''));

        // credenciais conforme regra
        set('salt', salt);
        set('hash', hash);
        set('verified', true);
        set('verifyToken',''); set('verifyExpires','');
        set('resetToken','');  set('resetExpires','');

        if (row>0){
          sh.getRange(row,1,1,line.length).setValues([line]);
          updated++;
        } else {
          sh.appendRow(line);
          // atualiza índice para não inserir de novo se mesmo e-mail aparecer (já bloqueamos dup no CSV, mas por segurança)
          email2row[payload.email] = sh.getLastRow();
          inserted++;
        }
      } catch(e){
        errors++; if (!sampleErr) sampleErr = 'L'+(idxRow+2)+': '+ e.message;
      }
    });

    return ok_({result:'ok', inserted, updated, errors, sampleError: sampleErr});
  } catch(err){
    return ok_({result:'error', message:String(err)});
  }
}
// Normaliza e-mail
function normEmail_(s){ return String(s||'').trim().toLowerCase(); }

// Garante header e devolve a aba "Usuários"
function shUsers_(){ return ensureUsersHeader_(); }

// Todas as linhas (números de linha) que possuem esse e-mail
function users_findRowsByEmail_(email){
  const sh = shUsers_();
  const col = getHeaderMapUsersFull_(sh);
  const last = sh.getLastRow();
  if (last < 2 || !col.email) return [];
  const vals = sh.getRange(2, col.email, last-1, 1).getValues().flat();
  const target = normEmail_(email);
  const rows = [];
  for (let i=0;i<vals.length;i++){
    if (normEmail_(vals[i]) === target) rows.push(i+2);
  }
  return rows;
}

// (opcional) padroniza retorno usado nos handlers do HTML
function ok_(o){ return o; }
// Retorna e-mails (lowercase) de avaliadores que JÁ AVALIARAM (status concluída) uma empresa
function admin_listPastEvaluators_(empresaId){
  const id = String(empresaId||'').trim();
  if (!id) return [];
  const sh = getAvaliacoesSheet_();
  const col = getHeaderMap_(sh);
  const last = sh.getLastRow();
  if (last < 2 || !col.empresaId || !col.avaliadorEmail) return [];

  const seen = {};
  const rows = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();
  for (let i=0;i<rows.length;i++){
    const r = mapRowToEvaluation_(rows[i], col);
    if (String(r.empresaId) !== id) continue;
    const em = String(r.avaliadorEmail||'').trim().toLowerCase();
    if (!em) continue;
    const st = String(r.status||'').toLowerCase();
    // considera apenas quem JÁ AVALIOU (concluída)
    if (st === 'concluída' || st === 'concluida') {
      seen[em] = true;
    }
  }
  return Object.keys(seen);
}

// Wrapper exposto ao front-end
function admin_listPastEvaluators(empresaId){ 
  return admin_listPastEvaluators_(empresaId); 
}
/** Retorna a planilha "Cadastros SuperSeller".
 *  Se o App for standalone, defina em Script Properties: CADASTROS_SUPERSELLER_ID = <ID da planilha>.
 */
var __CADASTROS_SS_MEM__ = null;
function getCadastrosSS_() {
  if (__CADASTROS_SS_MEM__) return __CADASTROS_SS_MEM__;
  const props = PropertiesService.getScriptProperties();
  const id = props.getProperty('CADASTROS_SUPERSELLER_ID');
  if (id) {
    try { __CADASTROS_SS_MEM__ = SpreadsheetApp.openById(id); return __CADASTROS_SS_MEM__; }
    catch (e) { Logger.log('[getCadastrosSS_] Falha ao abrir CADASTROS_SUPERSELLER_ID=%s (%s)', id, e); }
  }
  try { __CADASTROS_SS_MEM__ = SpreadsheetApp.openById(SPREADSHEET_ID); return __CADASTROS_SS_MEM__; }
  catch (e2) { Logger.log('[getCadastrosSS_] Falha ao abrir SPREADSHEET_ID=%s (%s)', SPREADSHEET_ID, e2); }
  try { __CADASTROS_SS_MEM__ = SpreadsheetApp.getActiveSpreadsheet(); if (__CADASTROS_SS_MEM__) return __CADASTROS_SS_MEM__; }
  catch (_) {}
  const files = DriveApp.getFilesByName('Cadastros SuperSeller');
  if (files.hasNext()) {
    __CADASTROS_SS_MEM__ = SpreadsheetApp.open(files.next());
    return __CADASTROS_SS_MEM__;
  }
  throw new Error('Planilha "Cadastros SuperSeller" não encontrada. Defina CADASTROS_SUPERSELLER_ID nas Script Properties.');
}

/** Le o cabeçalho + linhas de uma aba e devolve array de objetos. */
function readSheetAsObjects_(sheetName) {
  const sh = getCadastrosSS_().getSheetByName(sheetName);
  if (!sh) return [];
  const values = sh.getDataRange().getValues();
  if (!values || values.length < 2) return [];
  const head = values[0].map(h => String(h || '').trim());
  const idx = {}; head.forEach((h,i)=> idx[h.toLowerCase()] = i);
  const get = (row, ...names) => {
    for (const n of names) {
      const i = idx[String(n).toLowerCase()];
      if (i != null) return row[i];
    }
    return '';
  };
  const toIso = v => {
    if (typeof v === 'number') { // serial Excel
      const ms = Math.round((v - 25569) * 86400000);
      return Utilities.formatDate(new Date(ms), Session.getScriptTimeZone(), 'yyyy-MM-dd');
    }
    const s = String(v || '').trim();
    const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m) {
      let [_, d, mo, y] = m; if (y.length === 2) y = '20' + y;
      return `${y.padStart(4,'0')}-${mo.padStart(2,'0')}-${d.padStart(2,'0')}`;
    }
    return /^\d{4}-\d{2}-\d{2}/.test(s) ? s : '';
  };

  return values.slice(1)
    .filter(r => r && r.join('').trim() !== '')
    .map(r => ({
      jobId:         get(r,'jobId','job','ID','Id'),
      empresaId:     get(r,'empresaId','EmpresaId'),
      empresaNome:   get(r,'empresaNome','empresa','Empresa'),
      email:         get(r,'email','avaliador','Avaliador'),
      dataISO:       toIso(get(r,'dataISO','data','Data')),
      periodo:       get(r,'periodo','Período','Periodo'),
      voucherCodigo: get(r,'voucherCodigo','voucher','Voucher','voucherCode'),
      status:        get(r,'status','Status','situacao','Situação','Situacao') || 'Pendente'
    }));
}
/** ===================== ADMIN – Lista de Avaliações Atribuídas ===================== */
function admin_listAvaliacoesAtribuidas_(){
  const sh  = getAvaliacoesSheet_();
  const last = sh.getLastRow();
  if (last < 2) return [];

  const col   = getHeaderMap_(sh);                 // já reconhece nomeAvaliador/avaliadorNome/dataISO/empresaNome etc.
  const rows  = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();

  return rows.map(r => mapRowToEvaluation_(r, col)).map(v => ({
    // identificação
    jobId:          v.jobId || '',
    empresaId:      v.empresaId || '',
    empresaNome:    v.empresaNome || v.estabelecimento || '',

    // pessoa
    avaliadorEmail: (v.avaliadorEmail || '').toLowerCase(),
    nomeAvaliador:  v.nomeAvaliador || v.avaliadorNome || '',

    // data/tempo
    dataISO:        String(v.dataISO || ''),   // já em YYYY-MM-DD
    periodo:        v.periodo || '',           // a UI já sabe mostrar
    hora:           v.hora || '',

    // voucher / status
    voucherValor:   (typeof v.voucherValor === 'number') ? v.voucherValor : (Number(v.voucherValor) || ''),
    voucherCodigo:  v.voucherCodigo || '',
    status:         v.status || 'Pendente'
  }));
}
function admin_listAvaliacoesAtribuidas(){ return admin_listAvaliacoesAtribuidas_(); }

/** ===================== ADMIN – Lista de Vouchers (com status) ===================== */
function admin_listVouchers_(){
  // Lê avaliações atribuídas e mapa de resgates, junta e devolve itens para o Admin.html
  const shA = getAvaliacoesSheet_();
  const last = shA.getLastRow();
  if (last < 2) return [];
  const colA = getHeaderMap_(shA);
  const rows = shA.getRange(2,1,last-1,shA.getLastColumn()).getValues();

  // Constrói mapas de resgates por código e também por jobId (fallback)
  const shR = getRedeemsSheet_();
  const lastR = shR.getLastRow();
  const colR = getHeaderMapRedeems_(shR);
  const byCode = {}, byJob = {};
  const normCode = s => String(s||'').trim().toLowerCase().replace(/[^a-z0-9]/g,'');
  if (lastR >= 2) {
    const valsR = shR.getRange(2,1,lastR-1,shR.getLastColumn()).getValues();
    for (let i=0;i<valsR.length;i++){
      const r = valsR[i];
      const code = normCode(colR.code ? r[colR.code-1] : '');
      const job  = String(colR.jobId ? r[colR.jobId-1] : '').trim();
      const redObj = {
        redeemedAt: colR.redeemed_at ? r[colR.redeemed_at-1] : '',
        redeemedBy: colR.partner_email ? String(r[colR.partner_email-1]||'') : ''
      };
      if (code) byCode[code] = redObj;
      if (job)  byJob[job] = redObj;
    }
  }

  const items = rows.map(r => mapRowToEvaluation_(r, colA)).map(v => {
    const code = String(v.voucherCodigo||'');
    const red  = (code && byCode[normCode(code)]) || (v.jobId && byJob[String(v.jobId).trim()]) || null;
    const redeemed = !!(red && red.redeemedAt);
    return {
      empresaId:    v.empresaId || '',
      empresaNome:  v.empresaNome || v.estabelecimento || '',
      jobId:        v.jobId || '',
      dataISO:      String(v.dataISO||''),
      periodo:      v.periodo || '',
      voucher:      code,
      redeemed:     redeemed,
      redeemedAt:   red ? red.redeemedAt || '' : '',
      redeemedBy:   red ? red.redeemedBy || '' : ''
    };
  });
  // Ordena desc por dataISO (YYYY-MM-DD)
  items.sort((a,b)=> String(b.dataISO||'').localeCompare(String(a.dataISO||'')) );
  return items;
}
function admin_listVouchers(){ return admin_listVouchers_(); }

/** ===================== ADMIN – Validação Manual de Voucher ===================== */
function admin_manualVoucherRedeem_(payload){
  const codeRaw = (payload && (payload.code || payload.voucher)) || '';
  const code = String(codeRaw||'').trim();
  if (!code) return { result:'invalid_request', message:'Código obrigatório' };

  const shA = getAvaliacoesSheet_();
  const colA = getHeaderMap_(shA);
  const last = shA.getLastRow();
  if (last < 2 || !colA.voucherCodigo) return { result:'not_found', message:'Sem avaliações ou coluna voucher' };

  // procura voucher (case-insensitive)
  const list = shA.getRange(2, colA.voucherCodigo, last-1, 1).getValues().flat();
  const idx = list.findIndex(v => String(v).trim().toLowerCase() === code.toLowerCase());
  if (idx === -1) return { result:'not_found', message:'Voucher não encontrado' };
  const row = idx + 2;
  const rec  = mapRowToEvaluation_(shA.getRange(row,1,1,shA.getLastColumn()).getValues()[0], colA);

  // já resgatado?
  const redeemMap = getRedeemsMap_();
  const red = rec.voucherCodigo ? (redeemMap[String(rec.voucherCodigo).trim().toLowerCase()] || null) : null;
  if (red && red.redeemedAt) return { result:'already_redeemed' };

  // grava em PartnerVoucherRedeems
  const shR = getRedeemsSheet_();
  const head = shR.getRange(1,1,1, Math.max(1, shR.getLastColumn())).getValues()[0].map(String);
  const norm = s => String(s||'').toLowerCase().replace(/[^a-z0-9_]+/g,'');
  const idxs = {};
  head.forEach((h,i)=> idxs[norm(h)] = i);
  const getCol = (name, fallbackIndex) => (idxs[norm(name)]!=null ? idxs[norm(name)]+1 : fallbackIndex);

  const now = new Date();
  const tz  = Session.getScriptTimeZone();
  const ts  = Utilities.formatDate(now, tz, "yyyy-MM-dd'T'HH:mm:ssXXX");

  // monta linha nas colunas conhecidas
  const rowVals = new Array(Math.max(7, shR.getLastColumn())).fill('');
  const set = (name, value) => { const c = getCol(name); if (c) rowVals[c-1] = value; };

  // preencher
  if (getCol('code',1))           rowVals[getCol('code',1)-1] = String(rec.voucherCodigo||code);
  if (getCol('jobId',2))          rowVals[getCol('jobId',2)-1] = String(rec.jobId||'');
  if (getCol('estabelecimento',3))rowVals[getCol('estabelecimento',3)-1] = String(rec.estabelecimento || rec.empresaNome || '');
  if (getCol('redeemed_at',4))    rowVals[getCol('redeemed_at',4)-1] = ts;
  if (getCol('partner_email',5))  rowVals[getCol('partner_email',5)-1] = 'admin';
  if (getCol('rating',6))         rowVals[getCol('rating',6)-1] = '';
  if (getCol('ratingObs',7))      rowVals[getCol('ratingObs',7)-1] = 'Manual (Admin.html)';

  shR.appendRow(rowVals);
  return { result:'ok' };
}
function admin_manualVoucherRedeem(p){ return admin_manualVoucherRedeem_(p); }

/** ===================== ADMIN – Lista de Resgates (fallback / depuração) ===================== */
function admin_listRedeems_(){
  const sh = getRedeemsSheet_();
  const last = sh.getLastRow();
  if (last < 2) return [];
  const col = getHeaderMapRedeems_(sh);
  const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  const out = [];
  for (let i=0;i<vals.length;i++){
    const r = vals[i];
    out.push({
      code: String(col.code ? r[col.code-1] : ''),
      jobId: String(col.jobId ? r[col.jobId-1] : ''),
      estabelecimento: String(col.estabelecimento ? r[col.estabelecimento-1] : ''),
      redeemed_at: col.redeemed_at ? r[col.redeemed_at-1] : '',
      partner_email: String(col.partner_email ? r[col.partner_email-1] : ''),
      rating: (col.rating && r[col.rating-1] !== '' ? Number(r[col.rating-1]) : null),
      ratingObs: String(col.ratingObs ? r[col.ratingObs-1] : '')
    });
  }
  return out;
}
function admin_listRedeems(){ return admin_listRedeems_(); }

// Isola envio de e-mail de teste para reaproveitar nos handlers em lote.
function admin_testEmail_(payload){
  const to = String(payload && payload.to || '').trim() || Session.getActiveUser().getEmail();
  try {
    GmailApp.sendEmail(to, 'Teste SuperSeller', 'Teste OK', { htmlBody:'<b>Teste OK</b>', ..._emailOpts_() });
    return { result:'ok', message:'GmailApp OK', to, version: VERSION };
  } catch (e1) {
    try {
      MailApp.sendEmail({ to, subject:'Teste SuperSeller (fallback)', htmlBody:'<b>Teste via MailApp</b>', name: EMAIL_NAME, replyTo: EMAIL_FROM });
      return { result:'ok', message:'MailApp fallback OK', to, warn:String(e1), version: VERSION };
    } catch (e2) {
      return { result:'error', message:'Falha total no envio', gmailError:String(e1), mailError:String(e2), version: VERSION };
    }
  }
}


/** Opcional: genérica (o HTML também tenta chamar esta). */
function admin_listSheet(sheetName) {
  return readSheetAsObjects_(sheetName);
}

/** ===================== ADMIN – Limpeza de Cabeçalhos (AvaliacoesAtribuidas) =====================
 *  Une colunas duplicadas por alias e remove redundantes.
 *  - Mantém a primeira coluna encontrada como "primária" para cada campo canônico
 *  - Move valores não vazios das duplicadas para a primária (sem sobrescrever valores já preenchidos)
 *  - Renomeia o cabeçalho da coluna primária para o rótulo canônico
 *  - Remove as colunas duplicadas (da direita para a esquerda)
 */
function admin_cleanupHeaders_(){
  const sh = getAvaliacoesSheet_();
  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastCol < 1) return { result:'ok', message:'Sheet vazio' };
  const headers = sh.getRange(1,1,1,lastCol).getValues()[0].map(String);

  // Mapa canônico: chave -> { label, aliases[] }
  const CANON = [
    ['empresaId',       ['empresaId','idempresa','empresa','companyid']],
    ['jobId',           ['jobId','id','job']],
    ['avaliadorEmail',  ['avaliadorEmail','emailavaliador','emailav','avaliador','email']],
    ['nomeAvaliador',   ['nomeAvaliador','avaliadornome','nome_avaliador']],
    ['avaliadorNome',   ['avaliadorNome','avaliadornome','nomeavaliador','avaliador_nome']],
    ['estabelecimento', ['estabelecimento','loja','unidade','nomeestabelecimento','empresa']],
    ['empresaNome',     ['empresaNome','empresa_nome','nomeempresa','estabelecimento','empresa','loja','unidade']],
    ['endereco',        ['endereco','endereço','address','logradouro']],
    ['cidade',          ['cidade','municipio','cidadeuf','city']],
    ['uf',              ['uf','estado','sigla','state']],
    ['latitude',        ['latitude','lat']],
    ['longitude',       ['longitude','lng','long','lon']],
    ['dataISO',         ['dataISO','data','datayyyymmdd']],
    ['hora',            ['hora','horario','time']],
    ['periodo',         ['periodo','período','turno']],
    ['pdfPadraoURL',    ['pdfPadraoURL','pdfpadrao','padraourl','pdf']],
    ['formularioURL',   ['formularioURL','formurl','surveyurl','surveymonkey','formulario']],
    ['voucherValor',    ['voucherValor','valorvoucher','valor','reembolso']],
    ['voucherCodigo',   ['voucherCodigo','codvoucher','voucher','codigo','código']],
    ['status',          ['status','situacao','situacaoavaliacao']],
    ['observacoes',     ['observacoes','observacoesopcional','obs','observacao','observaçoes']],
    ['instagram',       ['instagram','ig']],
    ['site',            ['site','website','urlsite']],
    ['telefoneEstab',   ['telefoneEstab','telefone','tel','telefoneestabelecimento','fone']],
    ['surveyRespondentId',['surveyRespondentId','respondentid','sm_respondent_id','smrespondentid']],
    ['dataConclusao',   ['dataConclusao','conclusao','conclusão','finishedat','completedat']],
    ['audioUrl',        ['audioUrl','audiourl','audio','linkaudio','audiolink','url_audio','audio_url']],
    ['audioUploadedAt', ['audioUploadedAt','audiosentat','audiouploadedat','audio_enviado_em','audio_at','uploaded_at_audio']]
  ];

  const norm = s => String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase().replace(/[^a-z0-9]+/g,'');

  // Build groups: canonKey -> [colIndex]
  const groups = {};
  headers.forEach((h, idx) => {
    const hn = norm(h);
    for (const [key, aliases] of CANON){
      for (const a of aliases){
        if (hn === norm(a)){
          if (!groups[key]) groups[key] = [];
          groups[key].push(idx+1); // 1-based
          return;
        }
      }
    }
  });

  let merged = 0, removed = 0, renamed = 0;
  const toDelete = [];
  const nRows = Math.max(0, lastRow - 1);

  for (const [key, cols] of Object.entries(groups)){
    if (!cols || cols.length <= 1) {
      // Garantir rótulo canônico
      const idx = cols && cols[0];
      if (idx){ sh.getRange(1, idx).setValue(key); renamed++; }
      continue;
    }
    // Primária = a primeira ocorrência (mais à esquerda)
    const primary = Math.min.apply(null, cols);
    const dupes = cols.filter(c => c !== primary).sort((a,b)=>b-a); // direita→esquerda para deletar depois

    if (nRows > 0){
      const primVals = sh.getRange(2, primary, nRows, 1).getValues();
      const dupValsList = dupes.map(c => sh.getRange(2, c, nRows, 1).getValues());
      // Merge: preenche vazios na primária com o primeiro não vazio dentre as duplicadas
      for (let r=0; r<nRows; r++){
        if (String(primVals[r][0]||'').trim() === ''){
          for (let k=0;k<dupValsList.length;k++){
            const v = dupValsList[k][r][0];
            if (String(v||'').trim() !== ''){ primVals[r][0] = v; merged++; break; }
          }
        }
      }
      sh.getRange(2, primary, nRows, 1).setValues(primVals);
    }
    // Renomeia cabeçalho para a chave canônica
    sh.getRange(1, primary).setValue(key); renamed++;
    // Marca duplicadas para deleção
    toDelete.push(...dupes);
  }

  // Exclui duplicadas (ordem decrescente)
  toDelete.sort((a,b)=>b-a).forEach(colIdx => { try { sh.deleteColumn(colIdx); removed++; } catch(_){} });

  return { result:'ok', merged, removed, renamed, lastRow, lastColBefore:lastCol, lastColAfter: sh.getLastColumn() };
}
// Wrapper exposto ao Admin.html
function admin_cleanupHeaders(){ return admin_cleanupHeaders_(); }

/** ===================== PARCEIROS — Contas + Vínculo Empresas ===================== */
/** Planilha de parceiros e vínculos ficam na "Cadastros SuperSeller" */
function _partners_getPartnersSheet_(){
  const ss = getCadastrosSS_();
  let sh = ss.getSheetByName('PartnerAccounts');
  if (!sh) { sh = ss.insertSheet('PartnerAccounts'); }
  if (sh.getLastRow() === 0) {
    sh.appendRow(['id','username','email','password_salt','password_hash','status','created_at','last_login']);
  }
  return sh;
}
function _partners_getLinksSheet_(){
  const ss = getCadastrosSS_();
  let sh = ss.getSheetByName('PartnerCompanyLinks');
  if (!sh) { sh = ss.insertSheet('PartnerCompanyLinks'); }
  if (sh.getLastRow() === 0) {
    sh.appendRow(['partner_id','empresa_id','created_at']);
  }
  return sh;
}
function _partners_headerMap_(sh){
  const headers = sh.getRange(1,1,1,Math.max(1, sh.getLastColumn())).getValues()[0];
  const H = {}; headers.forEach((h,i)=> H[_norm_(h)] = i+1);
  function col(){ for (var i=0;i<arguments.length;i++){ var k=_norm_(arguments[i]); if (H[k]) return H[k]; } return null; }
  return {
    id: col('id'),
    username: col('username','user','login'),
    email: col('email','e-mail','mail'),
    password_salt: col('password_salt','salt'),
    password_hash: col('password_hash','hash'),
    status: col('status','situacao','situação'),
    created_at: col('created_at','criado','criado_em','createdat'),
    last_login: col('last_login','lastlogin','ultimo_login','último_login'),
  };
}
function _partners_findBy_(field, value){
  const sh = _partners_getPartnersSheet_();
  const col = _partners_headerMap_(sh);
  const keyCol = col[field]; if (!keyCol) return null;
  const last = sh.getLastRow(); if (last < 2) return null;
  const vals = sh.getRange(2, keyCol, last-1, 1).getValues().flat();
  const target = String(value||'').trim().toLowerCase();
  const idx = vals.findIndex(v => String(v||'').trim().toLowerCase() === target);
  if (idx === -1) return null;
  return { row: idx+2, col };
}
function _partners_genId_(){ return 'PA-' + randomHex(4).toUpperCase(); }
function _partners_pwdHash_(plain, salt){ return sha256Hex(String(plain||'') + '|' + String(salt||'') + '|' + getPepper()); }

/** Lista contas de parceiros (com empresas vinculadas) */
function admin_partner_listAccounts_(){
  const sh = _partners_getPartnersSheet_();
  const col = _partners_headerMap_(sh);
  const last = sh.getLastRow();
  const out = [];
  if (last >= 2){
    const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
    const links = _partners_listLinksMap_(); // { partner_id: Set(empresaIds) }
    for (let i=0;i<vals.length;i++){
      const r = vals[i];
      const id = String(col.id ? r[col.id-1] : '');
      out.push({
        id,
        username: String(col.username ? r[col.username-1] : ''),
        email: String(col.email ? r[col.email-1] : ''),
        status: String(col.status ? r[col.status-1] : ''),
        created_at: col.created_at ? r[col.created_at-1] : '',
        last_login: col.last_login ? r[col.last_login-1] : '',
        empresaIds: Array.from(links[id] || [])
      });
    }
  }
  return out;
}

/** Obtém uma conta específica (por id/username/email) + vínculos */
function admin_partner_getAccount_(idOrUserOrEmail){
  const sh = _partners_getPartnersSheet_();
  const col = _partners_headerMap_(sh);
  const last = sh.getLastRow(); if (last < 2) return null;
  const key = String(idOrUserOrEmail||'').trim(); if (!key) return null;

  const rows = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
  let acc = null;
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const id  = String(col.id ? r[col.id-1] : '');
    const un  = String(col.username ? r[col.username-1] : '');
    const em  = String(col.email ? r[col.email-1] : '');
    if (key === id || key.toLowerCase() === un.toLowerCase() || key.toLowerCase() === em.toLowerCase()){
      acc = {
        id,
        username: un,
        email: em,
        status: String(col.status ? r[col.status-1] : ''),
        created_at: col.created_at ? r[col.created_at-1] : '',
        last_login: col.last_login ? r[col.last_login-1] : ''
      };
      break;
    }
  }
  if (!acc) return null;
  const links = _partners_listLinksMap_();
  acc.empresaIds = Array.from(links[acc.id] || []);
  return acc;
}

/** Cria/atualiza conta. Se passwordPlain vier vazio em update, mantém hash atual. */
function admin_partner_upsertAccount_(payload){
  const p = payload || {};
  let { id, username, email, passwordPlain, status } = p;
  username = String(username||'').trim();
  email    = String(email||'').trim().toLowerCase();
  status   = String(status||'ativo').trim();
  const passwordRaw = passwordPlain == null ? '' : String(passwordPlain);
  const passwordTrim = passwordRaw.trim();
  const hasNewPassword = passwordTrim.length > 0;
  if (!username || !email) return { result:'error', message:'username e email são obrigatórios' };
  if (!id && !hasNewPassword) return { result:'error', message:'Senha obrigatória para criar conta' };
  if (hasNewPassword && passwordTrim.length < 4) return { result:'error', message:'Senha deve ter pelo menos 4 caracteres' };

  const sh = _partners_getPartnersSheet_();
  const col = _partners_headerMap_(sh);
  const last = sh.getLastRow();

  // unicidade username/email
  if (last >= 2){
    const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
    for (let i=0;i<vals.length;i++){
      const r = vals[i];
      const rid = String(col.id ? r[col.id-1] : '');
      const un  = String(col.username ? r[col.username-1] : '').trim().toLowerCase();
      const em  = String(col.email ? r[col.email-1] : '').trim().toLowerCase();
      const sameRow = (id && rid === id);
      if (!sameRow && (un === username.toLowerCase() || em === email)){
        return { result:'error', message:'username ou email já em uso' };
      }
    }
  }

  // localizar linha (por id se vier)
  let row = -1;
  if (id){
    const hit = _partners_findBy_('id', id);
    if (hit) row = hit.row; else id = '';
  }

  // (re)hash somente se informado
  let salt = '', hash = '';
  if (hasNewPassword){
    salt = randomHex(16);
    hash = _partners_pwdHash_(passwordTrim, salt);
  }

  if (row === -1){
    id = id || _partners_genId_();
    const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
    const arr = new Array(headers.length).fill('');
    if (col.id)            arr[col.id-1] = id;
    if (col.username)      arr[col.username-1] = username;
    if (col.email)         arr[col.email-1] = email;
    if (col.password_salt) arr[col.password_salt-1] = salt;
    if (col.password_hash) arr[col.password_hash-1] = hash;
    if (col.status)        arr[col.status-1] = status;
    if (col.created_at)    arr[col.created_at-1] = new Date();
    sh.appendRow(arr);
  } else {
    if (col.username) sh.getRange(row, col.username).setValue(username);
    if (col.email)    sh.getRange(row, col.email).setValue(email);
    if (hasNewPassword){
      if (col.password_salt) sh.getRange(row, col.password_salt).setValue(salt);
      if (col.password_hash) sh.getRange(row, col.password_hash).setValue(hash);
    }
    if (col.status)   sh.getRange(row, col.status).setValue(status);
  }
  return { result:'ok', id };
}

function admin_partner_listAccounts(){
  try { return { result:'ok', items: admin_partner_listAccounts_() }; }
  catch(e){ return { result:'error', message:String(e) }; }
}

/** Lê vínculos como mapa partner_id -> Set(empresaIds) */
function _partners_listLinksMap_(){
  const sh = _partners_getLinksSheet_();
  const last = sh.getLastRow();
  const map = {};
  if (last >= 2){
    const vals = sh.getRange(2,1,last-1,sh.getLastColumn()).getValues();
    for (let i=0;i<vals.length;i++){
      const pid = String(vals[i][0]||'').trim();
      const eid = String(vals[i][1]||'').trim();
      if (!pid || !eid) continue;
      if (!map[pid]) map[pid] = new Set();
      map[pid].add(eid);
    }
  }
  return map;
}

/** Define (substitui) os vínculos empresaIds de um parceiro */
function admin_partner_setLinks_(payload){
  const p = payload || {};
  const partnerId = String(p.partnerId||'').trim();
  const empresaIds = Array.isArray(p.empresaIds) ? p.empresaIds.map(String) : [];
  if (!partnerId) return { result:'error', message:'partnerId obrigatório' };
  const sh = _partners_getLinksSheet_();
  const last = sh.getLastRow();

  // remove existentes
  if (last >= 2){
    const vals = sh.getRange(2,1,last-1,2).getValues();
    const rowsToDelete = [];
    for (let i=0;i<vals.length;i++) if (String(vals[i][0]||'').trim() === partnerId) rowsToDelete.push(i+2);
    rowsToDelete.sort((a,b)=>b-a).forEach(r=>{ try{ sh.deleteRow(r); }catch(_){} });
  }

  // adiciona novos
  const now = new Date();
  empresaIds.filter(Boolean).forEach(eid => sh.appendRow([partnerId, String(eid), now]));
  return { result:'ok', partnerId, count: empresaIds.length };
}

// Exports para o Admin.html
function admin_partner_getAccount(idOrKey){ return admin_partner_getAccount_(idOrKey); }
function admin_partner_upsertAccount(payload){ return admin_partner_upsertAccount_(payload); }
function admin_partner_setLinks(payload){ return admin_partner_setLinks_(payload); }
